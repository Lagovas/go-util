<html>
	<head>
		<title>Package github.com/metaleap/go-util/str</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/metaleap/go-util/str</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/metaleap/go-util/str"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Various line-savers for common string-processing needs.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#Concat">func Concat(vals ...string) string</a></dd>
			
				
				<dd><a href="#ContainsOnce">func ContainsOnce(str1, str2 string) bool</a></dd>
			
				
				<dd><a href="#Distance">func Distance(s1, s2 string) int</a></dd>
			
				
				<dd><a href="#Equivalent">func Equivalent(one, two []string) bool</a></dd>
			
				
				<dd><a href="#First">func First(predicate func(s string) bool, step int, vals ...string) string</a></dd>
			
				
				<dd><a href="#FirstNonEmpty">func FirstNonEmpty(step int, vals ...string) string</a></dd>
			
				
				<dd><a href="#Ifm">func Ifm(cond bool, ifTrue, ifFalse map[string]string) map[string]string</a></dd>
			
				
				<dd><a href="#InSliceAt">func InSliceAt(vals []string, val string) int</a></dd>
			
				
				<dd><a href="#InSliceAtIgnoreCase">func InSliceAtIgnoreCase(vals []string, val string) int</a></dd>
			
				
				<dd><a href="#IsAscii">func IsAscii(str string) bool</a></dd>
			
				
				<dd><a href="#IsInSlice">func IsInSlice(vals []string, val string) bool</a></dd>
			
				
				<dd><a href="#IsInSliceIgnoreCase">func IsInSliceIgnoreCase(vals []string, val string) bool</a></dd>
			
				
				<dd><a href="#IsLower">func IsLower(s string) bool</a></dd>
			
				
				<dd><a href="#IsOneOf">func IsOneOf(s string, all ...string) bool</a></dd>
			
				
				<dd><a href="#IsUpper">func IsUpper(s string) bool</a></dd>
			
				
				<dd><a href="#LettersOnly">func LettersOnly(s string) (ret string)</a></dd>
			
				
				<dd><a href="#NonEmpties">func NonEmpties(breakAtFirstEmpty bool, vals ...string) []string</a></dd>
			
				
				<dd><a href="#Pluralize">func Pluralize(s string) string</a></dd>
			
				
				<dd><a href="#PrefixWithSep">func PrefixWithSep(prefix, sep, v string) string</a></dd>
			
				
				<dd><a href="#PrependIf">func PrependIf(s, p string) string</a></dd>
			
				
				<dd><a href="#Replace">func Replace(str string, repls map[string]string) string</a></dd>
			
				
				<dd><a href="#RuneAt">func RuneAt(str string, pos int) rune</a></dd>
			
				
				<dd><a href="#SafeIdentifier">func SafeIdentifier(s string) (ret string)</a></dd>
			
				
				<dd><a href="#Split">func Split(v, s string) (sl []string)</a></dd>
			
				
				<dd><a href="#StripPrefix">func StripPrefix(val, prefix string) string</a></dd>
			
				
				<dd><a href="#StripSuffix">func StripSuffix(val, suffix string) string</a></dd>
			
				
				<dd><a href="#ToLowerIfUpper">func ToLowerIfUpper(s string) string</a></dd>
			
				
				<dd><a href="#ToUpperIfLower">func ToUpperIfLower(s string) string</a></dd>
			
				
				<dd><a href="#Without">func Without(slice []string, keepOrder bool, withoutVals ...string) []string</a></dd>
			
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/str.go">str.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="Concat">func <a href="/target/str.go?s=173:207#L4">Concat</a></h2>
			<pre>func Concat(vals ...string) string</pre>
			<p>
Does a strings.Join() on the specified string values.
</p>

			
		
			
			
			<h2 id="ContainsOnce">func <a href="/target/str.go?s=303:344#L9">ContainsOnce</a></h2>
			<pre>func ContainsOnce(str1, str2 string) bool</pre>
			<p>
Returns true if str2 is contained in str1 exactly once.
</p>

			
		
			
			
			<h2 id="Distance">func <a href="/target/str.go?s=536:568#L18">Distance</a></h2>
			<pre>func Distance(s1, s2 string) int</pre>
			<p>
A simple string-similarity algorithm.
</p>

			
		
			
			
			<h2 id="Equivalent">func <a href="/target/str.go?s=1183:1222#L41">Equivalent</a></h2>
			<pre>func Equivalent(one, two []string) bool</pre>
			<p>
Returns true if one and two contain the same strings, regardless of their respective slice positions.
</p>

			
		
			
			
			<h2 id="First">func <a href="/target/str.go?s=1621:1695#L57">First</a></h2>
			<pre>func First(predicate func(s string) bool, step int, vals ...string) string</pre>
			<p>
Returns the first string in vals to match the specified predicate.
step: 1 to test all values. A higher value to skip n values after each test. Negative for reverse slice traversal. Or use 0 to get stuck in an infinite loop.
</p>

			
		
			
			
			<h2 id="FirstNonEmpty">func <a href="/target/str.go?s=1967:2018#L70">FirstNonEmpty</a></h2>
			<pre>func FirstNonEmpty(step int, vals ...string) string</pre>
			<p>
Returns the first non-empty string in vals.
step: see First() function.
</p>

			
		
			
			
			<h2 id="Ifm">func <a href="/target/str.go?s=2269:2341#L79">Ifm</a></h2>
			<pre>func Ifm(cond bool, ifTrue, ifFalse map[string]string) map[string]string</pre>
			<p>
Returns ifTrue if cond is true, otherwise returns ifFalse.
</p>

			
		
			
			
			<h2 id="InSliceAt">func <a href="/target/str.go?s=2433:2478#L87">InSliceAt</a></h2>
			<pre>func InSliceAt(vals []string, val string) int</pre>
			<p>
Returns the position of val in vals.
</p>

			
		
			
			
			<h2 id="InSliceAtIgnoreCase">func <a href="/target/str.go?s=2618:2673#L97">InSliceAtIgnoreCase</a></h2>
			<pre>func InSliceAtIgnoreCase(vals []string, val string) int</pre>
			<p>
Returns the position of lower-case val in lower-case vals.
</p>

			
		
			
			
			<h2 id="IsAscii">func <a href="/target/str.go?s=2858:2887#L108">IsAscii</a></h2>
			<pre>func IsAscii(str string) bool</pre>
			<p>
Returns true if str is ASCII-compatible.
</p>

			
		
			
			
			<h2 id="IsInSlice">func <a href="/target/str.go?s=3017:3063#L118">IsInSlice</a></h2>
			<pre>func IsInSlice(vals []string, val string) bool</pre>
			<p>
Returns true if val is in vals.
</p>

			
		
			
			
			<h2 id="IsInSliceIgnoreCase">func <a href="/target/str.go?s=3160:3216#L123">IsInSliceIgnoreCase</a></h2>
			<pre>func IsInSliceIgnoreCase(vals []string, val string) bool</pre>
			<p>
Returns true if lower-case val is in lower-case vals.
</p>

			
		
			
			
			<h2 id="IsLower">func <a href="/target/str.go?s=3323:3350#L128">IsLower</a></h2>
			<pre>func IsLower(s string) bool</pre>
			<p>
Returns true if all Letter-runes in s are lower-case.
</p>

			
		
			
			
			<h2 id="IsOneOf">func <a href="/target/str.go?s=3497:3539#L138">IsOneOf</a></h2>
			<pre>func IsOneOf(s string, all ...string) bool</pre>
			<p>
Returns true if s is in all.
</p>

			
		
			
			
			<h2 id="IsUpper">func <a href="/target/str.go?s=3677:3704#L148">IsUpper</a></h2>
			<pre>func IsUpper(s string) bool</pre>
			<p>
Returns true if all Letter-runes in s are upper-case.
</p>

			
		
			
			
			<h2 id="LettersOnly">func <a href="/target/str.go?s=3894:3933#L158">LettersOnly</a></h2>
			<pre>func LettersOnly(s string) (ret string)</pre>
			<p>
Returns a string representation of s with all non-Letter-runes removed.
</p>

			
		
			
			
			<h2 id="NonEmpties">func <a href="/target/str.go?s=4088:4152#L168">NonEmpties</a></h2>
			<pre>func NonEmpties(breakAtFirstEmpty bool, vals ...string) []string</pre>
			<p>
Returns a slice that contains the non-empty strings in vals.
</p>

			
		
			
			
			<h2 id="Pluralize">func <a href="/target/str.go?s=4690:4721#L184">Pluralize</a></h2>
			<pre>func Pluralize(s string) string</pre>
			<p>
A most simplistic (not linguistically-correct) English-language pluralizer that may be useful for code or doc generation.
If s ends with &#34;s&#34;, only appends &#34;es&#34;: bus -&gt; buses, mess -&gt; messes
If s ends with &#34;y&#34; (but not &#34;ay&#34;, &#34;ey&#34;, &#34;oy&#34;, &#34;uy&#34; or &#34;iy&#34;), removes &#34;y&#34; and appends &#34;ies&#34;: autonomy -&gt; autonomies, dictionary -&gt; dictionaries etc.
Otherwise, appends &#34;s&#34;.
</p>

			
		
			
			
			<h2 id="PrefixWithSep">func <a href="/target/str.go?s=4996:5044#L195">PrefixWithSep</a></h2>
			<pre>func PrefixWithSep(prefix, sep, v string) string</pre>
			<p>
Prepends prefix + sep to v only if prefix isn&#39;t empty.
</p>

			
		
			
			
			<h2 id="PrependIf">func <a href="/target/str.go?s=5174:5208#L203">PrependIf</a></h2>
			<pre>func PrependIf(s, p string) string</pre>
			<p>
Prepends p to s only if s doesn&#39;t already have that prefix.
</p>

			
		
			
			
			<h2 id="Replace">func <a href="/target/str.go?s=5367:5423#L211">Replace</a></h2>
			<pre>func Replace(str string, repls map[string]string) string</pre>
			<p>
Replaces in str all occurrences of all repls map keys with their associated (mapped) value.
</p>

			
		
			
			
			<h2 id="RuneAt">func <a href="/target/str.go?s=5545:5582#L219">RuneAt</a></h2>
			<pre>func RuneAt(str string, pos int) rune</pre>
			<p>
Returns the rune in str at pos.
</p>

			
		
			
			
			<h2 id="SafeIdentifier">func <a href="/target/str.go?s=5730:5772#L229">SafeIdentifier</a></h2>
			<pre>func SafeIdentifier(s string) (ret string)</pre>
			<p>
Creates a Pascal-cased &#34;identifier&#34; version of the specified string.
</p>

			
		
			
			
			<h2 id="Split">func <a href="/target/str.go?s=6396:6433#L254">Split</a></h2>
			<pre>func Split(v, s string) (sl []string)</pre>
			<p>
Returns an empty slice is v is emtpy, otherwise like strings.Split()
</p>

			
		
			
			
			<h2 id="StripPrefix">func <a href="/target/str.go?s=6532:6575#L262">StripPrefix</a></h2>
			<pre>func StripPrefix(val, prefix string) string</pre>
			<p>
Strips prefix off val if possible.
</p>

			
		
			
			
			<h2 id="StripSuffix">func <a href="/target/str.go?s=6698:6741#L270">StripSuffix</a></h2>
			<pre>func StripSuffix(val, suffix string) string</pre>
			<p>
Strips suffix off val if possible.
</p>

			
		
			
			
			<h2 id="ToLowerIfUpper">func <a href="/target/str.go?s=7797:7833#L324">ToLowerIfUpper</a></h2>
			<pre>func ToLowerIfUpper(s string) string</pre>
			<p>
Returns the lower-case representation of s only if it is currently fully upper-case as per IsUpper().
</p>

			
		
			
			
			<h2 id="ToUpperIfLower">func <a href="/target/str.go?s=8002:8038#L332">ToUpperIfLower</a></h2>
			<pre>func ToUpperIfLower(s string) string</pre>
			<p>
Returns the upper-case representation of s only if it is currently fully lower-case as per IsLower().
</p>

			
		
			
			
			<h2 id="Without">func <a href="/target/str.go?s=8141:8217#L340">Without</a></h2>
			<pre>func Without(slice []string, keepOrder bool, withoutVals ...string) []string</pre>
			<p>
Removes all withoutVals from slice.
</p>

			
		
		
		</div>
	

	








		</div></div>
	</body>
</html>