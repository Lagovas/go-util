<html>
	<head>
		<title>Package github.com/metaleap/go-util/str</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/metaleap/go-util/str</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/metaleap/go-util/str"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Various line-savers for common string-processing needs.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#Concat">func Concat(vals ...string) string</a></dd>
			
				
				<dd><a href="#ContainsOnce">func ContainsOnce(str1, str2 string) bool</a></dd>
			
				
				<dd><a href="#Distance">func Distance(s1, s2 string) int</a></dd>
			
				
				<dd><a href="#Equivalent">func Equivalent(one, two []string) bool</a></dd>
			
				
				<dd><a href="#ExtractAllIdentifiers">func ExtractAllIdentifiers(src, prefix string) (identifiers []string)</a></dd>
			
				
				<dd><a href="#ExtractFirstIdentifier">func ExtractFirstIdentifier(src, prefix string, minPos int) (identifier string)</a></dd>
			
				
				<dd><a href="#First">func First(predicate func(s string) bool, step int, vals ...string) string</a></dd>
			
				
				<dd><a href="#FirstNonEmpty">func FirstNonEmpty(vals ...string) (val string)</a></dd>
			
				
				<dd><a href="#HasAnyPrefix">func HasAnyPrefix(s string, prefixes ...string) bool</a></dd>
			
				
				<dd><a href="#HasAnySuffix">func HasAnySuffix(s string, suffixes ...string) bool</a></dd>
			
				
				<dd><a href="#Ifm">func Ifm(cond bool, ifTrue, ifFalse map[string]string) map[string]string</a></dd>
			
				
				<dd><a href="#Ifs">func Ifs(cond bool, ifTrue string, ifFalse string) string</a></dd>
			
				
				<dd><a href="#InSliceAt">func InSliceAt(vals []string, val string) int</a></dd>
			
				
				<dd><a href="#InSliceAtIgnoreCase">func InSliceAtIgnoreCase(vals []string, val string) int</a></dd>
			
				
				<dd><a href="#IndexAny">func IndexAny(s string, seps ...string) (pos int)</a></dd>
			
				
				<dd><a href="#IsAnyInSlice">func IsAnyInSlice(slice []string, vals ...string) bool</a></dd>
			
				
				<dd><a href="#IsAscii">func IsAscii(str string) bool</a></dd>
			
				
				<dd><a href="#IsInSlice">func IsInSlice(vals []string, val string) bool</a></dd>
			
				
				<dd><a href="#IsInSliceIgnoreCase">func IsInSliceIgnoreCase(vals []string, val string) bool</a></dd>
			
				
				<dd><a href="#IsLower">func IsLower(s string) bool</a></dd>
			
				
				<dd><a href="#IsOneOf">func IsOneOf(s string, all ...string) bool</a></dd>
			
				
				<dd><a href="#IsSimplePatternMatch">func IsSimplePatternMatch(s string, patterns ...string) bool</a></dd>
			
				
				<dd><a href="#IsUpper">func IsUpper(s string) bool</a></dd>
			
				
				<dd><a href="#LettersOnly">func LettersOnly(s string) (ret string)</a></dd>
			
				
				<dd><a href="#MatchSimplePattern">func MatchSimplePattern(s string, patterns ...string) string</a></dd>
			
				
				<dd><a href="#NonEmpties">func NonEmpties(breakAtFirstEmpty bool, vals ...string) (slice []string)</a></dd>
			
				
				<dd><a href="#Pluralize">func Pluralize(s string) string</a></dd>
			
				
				<dd><a href="#PrefixWithSep">func PrefixWithSep(prefix, sep, v string) string</a></dd>
			
				
				<dd><a href="#PrependIf">func PrependIf(s, p string) string</a></dd>
			
				
				<dd><a href="#Replace">func Replace(str string, repls map[string]string) string</a></dd>
			
				
				<dd><a href="#SafeIdentifier">func SafeIdentifier(s string) (ret string)</a></dd>
			
				
				<dd><a href="#Split">func Split(v, s string) (sl []string)</a></dd>
			
				
				<dd><a href="#StripPrefix">func StripPrefix(val, prefix string) string</a></dd>
			
				
				<dd><a href="#StripSuffix">func StripSuffix(val, suffix string) string</a></dd>
			
				
				<dd><a href="#ToLowerIfUpper">func ToLowerIfUpper(s string) string</a></dd>
			
				
				<dd><a href="#ToUpperIfLower">func ToUpperIfLower(s string) string</a></dd>
			
				
				<dd><a href="#Without">func Without(slice []string, keepOrder bool, withoutVals ...string) []string</a></dd>
			
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/str.go">str.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="Concat">func <a href="/target/str.go?s=149:183#L2">Concat</a></h2>
			<pre>func Concat(vals ...string) string</pre>
			<p>
Does a strings.Join() on the specified string values.
</p>

			
		
			
			
			<h2 id="ContainsOnce">func <a href="/target/str.go?s=279:320#L7">ContainsOnce</a></h2>
			<pre>func ContainsOnce(str1, str2 string) bool</pre>
			<p>
Returns true if str2 is contained in str1 exactly once.
</p>

			
		
			
			
			<h2 id="Distance">func <a href="/target/str.go?s=509:541#L16">Distance</a></h2>
			<pre>func Distance(s1, s2 string) int</pre>
			<p>
A simple string-similarity algorithm.
</p>

			
		
			
			
			<h2 id="Equivalent">func <a href="/target/str.go?s=1186:1225#L41">Equivalent</a></h2>
			<pre>func Equivalent(one, two []string) bool</pre>
			<p>
Returns true if one and two contain the same strings, regardless of their respective slice positions.
</p>

			
		
			
			
			<h2 id="ExtractAllIdentifiers">func <a href="/target/str.go?s=1499:1568#L56">ExtractAllIdentifiers</a></h2>
			<pre>func ExtractAllIdentifiers(src, prefix string) (identifiers []string)</pre>
			<p>
Extracts all identifiers (no duplicates, ordered by occurrence) starting with prefix occurring in src.
</p>

			
		
			
			
			<h2 id="ExtractFirstIdentifier">func <a href="/target/str.go?s=1936:2015#L69">ExtractFirstIdentifier</a></h2>
			<pre>func ExtractFirstIdentifier(src, prefix string, minPos int) (identifier string)</pre>
			<p>
Extracts the first occurrence (at or after minPos) of an identifier starting with prefix in src.
</p>

			
		
			
			
			<h2 id="First">func <a href="/target/str.go?s=2485:2559#L85">First</a></h2>
			<pre>func First(predicate func(s string) bool, step int, vals ...string) string</pre>
			<p>
Returns the first string in vals to match the specified predicate.
step: 1 to test all values. A higher value to skip n values after each test. Negative for reverse slice traversal. Or use 0 to get stuck in an infinite loop.
</p>

			
		
			
			
			<h2 id="FirstNonEmpty">func <a href="/target/str.go?s=2792:2839#L97">FirstNonEmpty</a></h2>
			<pre>func FirstNonEmpty(vals ...string) (val string)</pre>
			<p>
Returns the first non-empty string in vals.
</p>

			
		
			
			
			<h2 id="HasAnyPrefix">func <a href="/target/str.go?s=3060:3112#L108">HasAnyPrefix</a></h2>
			<pre>func HasAnyPrefix(s string, prefixes ...string) bool</pre>
			<p>
Returns true if s starts with any one of the specified prefixes.
</p>

			
		
			
			
			<h2 id="HasAnySuffix">func <a href="/target/str.go?s=3291:3343#L118">HasAnySuffix</a></h2>
			<pre>func HasAnySuffix(s string, suffixes ...string) bool</pre>
			<p>
Returns true if s ends with any one of the specified suffixes.
</p>

			
		
			
			
			<h2 id="Ifm">func <a href="/target/str.go?s=3518:3590#L128">Ifm</a></h2>
			<pre>func Ifm(cond bool, ifTrue, ifFalse map[string]string) map[string]string</pre>
			<p>
Returns ifTrue if cond is true, otherwise returns ifFalse.
</p>

			
		
			
			
			<h2 id="Ifs">func <a href="/target/str.go?s=3704:3761#L136">Ifs</a></h2>
			<pre>func Ifs(cond bool, ifTrue string, ifFalse string) string</pre>
			<p>
Returns ifTrue if cond is true, otherwise returns ifFalse.
</p>

			
		
			
			
			<h2 id="InSliceAt">func <a href="/target/str.go?s=4152:4197#L155">InSliceAt</a></h2>
			<pre>func InSliceAt(vals []string, val string) int</pre>
			<p>
Returns the position of val in vals.
</p>

			
		
			
			
			<h2 id="InSliceAtIgnoreCase">func <a href="/target/str.go?s=4337:4392#L165">InSliceAtIgnoreCase</a></h2>
			<pre>func InSliceAtIgnoreCase(vals []string, val string) int</pre>
			<p>
Returns the position of lower-case val in lower-case vals.
</p>

			
		
			
			
			<h2 id="IndexAny">func <a href="/target/str.go?s=3908:3957#L144">IndexAny</a></h2>
			<pre>func IndexAny(s string, seps ...string) (pos int)</pre>
			<p>
For all seps, computes the index of first occurrence in s, then returns the smallest index.
</p>

			
		
			
			
			<h2 id="IsAnyInSlice">func <a href="/target/str.go?s=4598:4652#L176">IsAnyInSlice</a></h2>
			<pre>func IsAnyInSlice(slice []string, vals ...string) bool</pre>
			<p>
Returns whether one of the specified vals is contained in slice.
</p>

			
		
			
			
			<h2 id="IsAscii">func <a href="/target/str.go?s=4937:4966#L194">IsAscii</a></h2>
			<pre>func IsAscii(str string) bool</pre>
			<p>
Returns true if str is ASCII-compatible.
</p>

			
		
			
			
			<h2 id="IsInSlice">func <a href="/target/str.go?s=5096:5142#L204">IsInSlice</a></h2>
			<pre>func IsInSlice(vals []string, val string) bool</pre>
			<p>
Returns true if val is in vals.
</p>

			
		
			
			
			<h2 id="IsInSliceIgnoreCase">func <a href="/target/str.go?s=5239:5295#L209">IsInSliceIgnoreCase</a></h2>
			<pre>func IsInSliceIgnoreCase(vals []string, val string) bool</pre>
			<p>
Returns true if lower-case val is in lower-case vals.
</p>

			
		
			
			
			<h2 id="IsLower">func <a href="/target/str.go?s=5402:5429#L214">IsLower</a></h2>
			<pre>func IsLower(s string) bool</pre>
			<p>
Returns true if all Letter-runes in s are lower-case.
</p>

			
		
			
			
			<h2 id="IsOneOf">func <a href="/target/str.go?s=5765:5807#L229">IsOneOf</a></h2>
			<pre>func IsOneOf(s string, all ...string) bool</pre>
			<p>
Returns true if s is in all.
</p>

			
		
			
			
			<h2 id="IsSimplePatternMatch">func <a href="/target/str.go?s=5615:5675#L224">IsSimplePatternMatch</a></h2>
			<pre>func IsSimplePatternMatch(s string, patterns ...string) bool</pre>
			<p>
Returns true if MatchSimplePattern(s, patterns...) returns a match.
</p>

			
		
			
			
			<h2 id="IsUpper">func <a href="/target/str.go?s=5945:5972#L239">IsUpper</a></h2>
			<pre>func IsUpper(s string) bool</pre>
			<p>
Returns true if all Letter-runes in s are upper-case.
</p>

			
		
			
			
			<h2 id="LettersOnly">func <a href="/target/str.go?s=6162:6201#L249">LettersOnly</a></h2>
			<pre>func LettersOnly(s string) (ret string)</pre>
			<p>
Returns a string representation of s with all non-Letter-runes removed.
</p>

			
		
			
			
			<h2 id="MatchSimplePattern">func <a href="/target/str.go?s=6542:6602#L260">MatchSimplePattern</a></h2>
			<pre>func MatchSimplePattern(s string, patterns ...string) string</pre>
			<p>
Checks s against the specified simple-patterns and returns the first matching pattern encountered, or &#34;&#34; if there is no match.
(A &#34;simple-pattern&#34; is a string that can optionally have one leading or trailing (or both) asterisk (&#39;*&#39;) wildcard.)
</p>

			
		
			
			
			<h2 id="NonEmpties">func <a href="/target/str.go?s=6977:7049#L270">NonEmpties</a></h2>
			<pre>func NonEmpties(breakAtFirstEmpty bool, vals ...string) (slice []string)</pre>
			<p>
Returns a slice that contains the non-empty strings in vals.
</p>

			
		
			
			
			<h2 id="Pluralize">func <a href="/target/str.go?s=7557:7588#L285">Pluralize</a></h2>
			<pre>func Pluralize(s string) string</pre>
			<p>
A most simplistic (not linguistically-correct) English-language pluralizer that may be useful for code or doc generation.
If s ends with &#34;s&#34;, only appends &#34;es&#34;: bus -&gt; buses, mess -&gt; messes
If s ends with &#34;y&#34; (but not &#34;ay&#34;, &#34;ey&#34;, &#34;oy&#34;, &#34;uy&#34; or &#34;iy&#34;), removes &#34;y&#34; and appends &#34;ies&#34;: autonomy -&gt; autonomies, dictionary -&gt; dictionaries etc.
Otherwise, appends &#34;s&#34;.
</p>

			
		
			
			
			<h2 id="PrefixWithSep">func <a href="/target/str.go?s=7863:7911#L296">PrefixWithSep</a></h2>
			<pre>func PrefixWithSep(prefix, sep, v string) string</pre>
			<p>
Prepends prefix + sep to v only if prefix isn&#39;t empty.
</p>

			
		
			
			
			<h2 id="PrependIf">func <a href="/target/str.go?s=8041:8075#L304">PrependIf</a></h2>
			<pre>func PrependIf(s, p string) string</pre>
			<p>
Prepends p to s only if s doesn&#39;t already have that prefix.
</p>

			
		
			
			
			<h2 id="Replace">func <a href="/target/str.go?s=8234:8290#L312">Replace</a></h2>
			<pre>func Replace(str string, repls map[string]string) string</pre>
			<p>
Replaces in str all occurrences of all repls map keys with their associated (mapped) value.
</p>

			
		
			
			
			<h2 id="SafeIdentifier">func <a href="/target/str.go?s=8449:8491#L320">SafeIdentifier</a></h2>
			<pre>func SafeIdentifier(s string) (ret string)</pre>
			<p>
Creates a Pascal-cased &#34;identifier&#34; version of the specified string.
</p>

			
		
			
			
			<h2 id="Split">func <a href="/target/str.go?s=9029:9066#L344">Split</a></h2>
			<pre>func Split(v, s string) (sl []string)</pre>
			<p>
Returns an empty slice is v is emtpy, otherwise like strings.Split()
</p>

			
		
			
			
			<h2 id="StripPrefix">func <a href="/target/str.go?s=9165:9208#L352">StripPrefix</a></h2>
			<pre>func StripPrefix(val, prefix string) string</pre>
			<p>
Strips prefix off val if possible.
</p>

			
		
			
			
			<h2 id="StripSuffix">func <a href="/target/str.go?s=9331:9374#L360">StripSuffix</a></h2>
			<pre>func StripSuffix(val, suffix string) string</pre>
			<p>
Strips suffix off val if possible.
</p>

			
		
			
			
			<h2 id="ToLowerIfUpper">func <a href="/target/str.go?s=10430:10466#L414">ToLowerIfUpper</a></h2>
			<pre>func ToLowerIfUpper(s string) string</pre>
			<p>
Returns the lower-case representation of s only if it is currently fully upper-case as per IsUpper().
</p>

			
		
			
			
			<h2 id="ToUpperIfLower">func <a href="/target/str.go?s=10635:10671#L422">ToUpperIfLower</a></h2>
			<pre>func ToUpperIfLower(s string) string</pre>
			<p>
Returns the upper-case representation of s only if it is currently fully lower-case as per IsLower().
</p>

			
		
			
			
			<h2 id="Without">func <a href="/target/str.go?s=10774:10850#L430">Without</a></h2>
			<pre>func Without(slice []string, keepOrder bool, withoutVals ...string) []string</pre>
			<p>
Removes all withoutVals from slice.
</p>

			
		
		
		</div>
	

	








		</div></div>
	</body>
</html>