<html>
	<head>
		<title>Package github.com/metaleap/go-util/str</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/metaleap/go-util/str</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/metaleap/go-util/str"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Various line-savers for common string-processing needs.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#AppendUnique">func AppendUnique(sl *[]string, s string)</a></dd>
			
				
				<dd><a href="#Concat">func Concat(vals ...string) string</a></dd>
			
				
				<dd><a href="#ContainsOnce">func ContainsOnce(str1, str2 string) bool</a></dd>
			
				
				<dd><a href="#Distance">func Distance(s1, s2 string) int</a></dd>
			
				
				<dd><a href="#Equivalent">func Equivalent(one, two []string) bool</a></dd>
			
				
				<dd><a href="#ExtractAllIdentifiers">func ExtractAllIdentifiers(src, prefix string) (identifiers []string)</a></dd>
			
				
				<dd><a href="#ExtractFirstIdentifier">func ExtractFirstIdentifier(src, prefix string, minPos int) (identifier string)</a></dd>
			
				
				<dd><a href="#First">func First(predicate func(s string) bool, step int, vals ...string) string</a></dd>
			
				
				<dd><a href="#FirstNonEmpty">func FirstNonEmpty(vals ...string) (val string)</a></dd>
			
				
				<dd><a href="#HasAnyPrefix">func HasAnyPrefix(s string, prefixes ...string) bool</a></dd>
			
				
				<dd><a href="#HasAnySuffix">func HasAnySuffix(s string, suffixes ...string) bool</a></dd>
			
				
				<dd><a href="#Ifm">func Ifm(cond bool, ifTrue, ifFalse map[string]string) map[string]string</a></dd>
			
				
				<dd><a href="#Ifs">func Ifs(cond bool, ifTrue string, ifFalse string) string</a></dd>
			
				
				<dd><a href="#InSliceAt">func InSliceAt(vals []string, val string) int</a></dd>
			
				
				<dd><a href="#InSliceAtIgnoreCase">func InSliceAtIgnoreCase(vals []string, val string) int</a></dd>
			
				
				<dd><a href="#IndexAny">func IndexAny(s string, seps ...string) (pos int)</a></dd>
			
				
				<dd><a href="#IsAnyInSlice">func IsAnyInSlice(slice []string, vals ...string) bool</a></dd>
			
				
				<dd><a href="#IsAscii">func IsAscii(str string) bool</a></dd>
			
				
				<dd><a href="#IsInSlice">func IsInSlice(vals []string, val string) bool</a></dd>
			
				
				<dd><a href="#IsInSliceIgnoreCase">func IsInSliceIgnoreCase(vals []string, val string) bool</a></dd>
			
				
				<dd><a href="#IsLower">func IsLower(s string) bool</a></dd>
			
				
				<dd><a href="#IsOneOf">func IsOneOf(s string, all ...string) bool</a></dd>
			
				
				<dd><a href="#IsUpper">func IsUpper(s string) bool</a></dd>
			
				
				<dd><a href="#LettersOnly">func LettersOnly(s string) (ret string)</a></dd>
			
				
				<dd><a href="#NonEmpties">func NonEmpties(breakAtFirstEmpty bool, vals ...string) (slice []string)</a></dd>
			
				
				<dd><a href="#Pluralize">func Pluralize(s string) string</a></dd>
			
				
				<dd><a href="#PrefixWithSep">func PrefixWithSep(prefix, sep, v string) string</a></dd>
			
				
				<dd><a href="#PrependIf">func PrependIf(s, p string) string</a></dd>
			
				
				<dd><a href="#Replace">func Replace(str string, repls map[string]string) string</a></dd>
			
				
				<dd><a href="#SafeIdentifier">func SafeIdentifier(s string) (ret string)</a></dd>
			
				
				<dd><a href="#Split">func Split(v, s string) (sl []string)</a></dd>
			
				
				<dd><a href="#StripPrefix">func StripPrefix(val, prefix string) string</a></dd>
			
				
				<dd><a href="#StripSuffix">func StripSuffix(val, suffix string) string</a></dd>
			
				
				<dd><a href="#ToLowerIfUpper">func ToLowerIfUpper(s string) string</a></dd>
			
				
				<dd><a href="#ToUpperIfLower">func ToUpperIfLower(s string) string</a></dd>
			
				
				<dd><a href="#Without">func Without(slice []string, keepOrder bool, withoutVals ...string) []string</a></dd>
			
			
				
				<dd><a href="#Buffer">type Buffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Write">func (me *Buffer) Write(format string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Writeln">func (me *Buffer) Writeln(format string, fmtArgs ...interface{})</a></dd>
				
			
				
				<dd><a href="#Matcher">type Matcher</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMatcher">func NewMatcher(patterns ...string) (me *Matcher)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Matcher.AddPattern">func (me *Matcher) AddPattern(s string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matcher.HasWildcardPatterns">func (me *Matcher) HasWildcardPatterns() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matcher.IsMatch">func (me *Matcher) IsMatch(s string) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matcher.Match">func (me *Matcher) Match(s string) string</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/buf.go">buf.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/match.go">match.go</a>
			
				<a href="/target/str.go">str.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="AppendUnique">func <a href="/target/str.go?s=150:191#L2">AppendUnique</a></h2>
			<pre>func AppendUnique(sl *[]string, s string)</pre>
			<p>
Appends s to sl only if sl does not already contain s.
</p>

			
		
			
			
			<h2 id="Concat">func <a href="/target/str.go?s=336:370#L12">Concat</a></h2>
			<pre>func Concat(vals ...string) string</pre>
			<p>
Does a strings.Join() on the specified string values.
</p>

			
		
			
			
			<h2 id="ContainsOnce">func <a href="/target/str.go?s=466:507#L17">ContainsOnce</a></h2>
			<pre>func ContainsOnce(str1, str2 string) bool</pre>
			<p>
Returns true if str2 is contained in str1 exactly once.
</p>

			
		
			
			
			<h2 id="Distance">func <a href="/target/str.go?s=696:728#L26">Distance</a></h2>
			<pre>func Distance(s1, s2 string) int</pre>
			<p>
A simple string-similarity algorithm.
</p>

			
		
			
			
			<h2 id="Equivalent">func <a href="/target/str.go?s=1373:1412#L51">Equivalent</a></h2>
			<pre>func Equivalent(one, two []string) bool</pre>
			<p>
Returns true if one and two contain the same strings, regardless of their respective slice positions.
</p>

			
		
			
			
			<h2 id="ExtractAllIdentifiers">func <a href="/target/str.go?s=1686:1755#L66">ExtractAllIdentifiers</a></h2>
			<pre>func ExtractAllIdentifiers(src, prefix string) (identifiers []string)</pre>
			<p>
Extracts all identifiers (no duplicates, ordered by occurrence) starting with prefix occurring in src.
</p>

			
		
			
			
			<h2 id="ExtractFirstIdentifier">func <a href="/target/str.go?s=2123:2202#L79">ExtractFirstIdentifier</a></h2>
			<pre>func ExtractFirstIdentifier(src, prefix string, minPos int) (identifier string)</pre>
			<p>
Extracts the first occurrence (at or after minPos) of an identifier starting with prefix in src.
</p>

			
		
			
			
			<h2 id="First">func <a href="/target/str.go?s=2672:2746#L95">First</a></h2>
			<pre>func First(predicate func(s string) bool, step int, vals ...string) string</pre>
			<p>
Returns the first string in vals to match the specified predicate.
step: 1 to test all values. A higher value to skip n values after each test. Negative for reverse slice traversal. Or use 0 to get stuck in an infinite loop.
</p>

			
		
			
			
			<h2 id="FirstNonEmpty">func <a href="/target/str.go?s=2979:3026#L107">FirstNonEmpty</a></h2>
			<pre>func FirstNonEmpty(vals ...string) (val string)</pre>
			<p>
Returns the first non-empty string in vals.
</p>

			
		
			
			
			<h2 id="HasAnyPrefix">func <a href="/target/str.go?s=3247:3299#L118">HasAnyPrefix</a></h2>
			<pre>func HasAnyPrefix(s string, prefixes ...string) bool</pre>
			<p>
Returns true if s starts with any one of the specified prefixes.
</p>

			
		
			
			
			<h2 id="HasAnySuffix">func <a href="/target/str.go?s=3478:3530#L128">HasAnySuffix</a></h2>
			<pre>func HasAnySuffix(s string, suffixes ...string) bool</pre>
			<p>
Returns true if s ends with any one of the specified suffixes.
</p>

			
		
			
			
			<h2 id="Ifm">func <a href="/target/str.go?s=3705:3777#L138">Ifm</a></h2>
			<pre>func Ifm(cond bool, ifTrue, ifFalse map[string]string) map[string]string</pre>
			<p>
Returns ifTrue if cond is true, otherwise returns ifFalse.
</p>

			
		
			
			
			<h2 id="Ifs">func <a href="/target/str.go?s=3891:3948#L146">Ifs</a></h2>
			<pre>func Ifs(cond bool, ifTrue string, ifFalse string) string</pre>
			<p>
Returns ifTrue if cond is true, otherwise returns ifFalse.
</p>

			
		
			
			
			<h2 id="InSliceAt">func <a href="/target/str.go?s=4339:4384#L165">InSliceAt</a></h2>
			<pre>func InSliceAt(vals []string, val string) int</pre>
			<p>
Returns the position of val in vals.
</p>

			
		
			
			
			<h2 id="InSliceAtIgnoreCase">func <a href="/target/str.go?s=4524:4579#L175">InSliceAtIgnoreCase</a></h2>
			<pre>func InSliceAtIgnoreCase(vals []string, val string) int</pre>
			<p>
Returns the position of lower-case val in lower-case vals.
</p>

			
		
			
			
			<h2 id="IndexAny">func <a href="/target/str.go?s=4095:4144#L154">IndexAny</a></h2>
			<pre>func IndexAny(s string, seps ...string) (pos int)</pre>
			<p>
For all seps, computes the index of first occurrence in s, then returns the smallest index.
</p>

			
		
			
			
			<h2 id="IsAnyInSlice">func <a href="/target/str.go?s=4785:4839#L186">IsAnyInSlice</a></h2>
			<pre>func IsAnyInSlice(slice []string, vals ...string) bool</pre>
			<p>
Returns whether one of the specified vals is contained in slice.
</p>

			
		
			
			
			<h2 id="IsAscii">func <a href="/target/str.go?s=5124:5153#L204">IsAscii</a></h2>
			<pre>func IsAscii(str string) bool</pre>
			<p>
Returns true if str is ASCII-compatible.
</p>

			
		
			
			
			<h2 id="IsInSlice">func <a href="/target/str.go?s=5283:5329#L214">IsInSlice</a></h2>
			<pre>func IsInSlice(vals []string, val string) bool</pre>
			<p>
Returns true if val is in vals.
</p>

			
		
			
			
			<h2 id="IsInSliceIgnoreCase">func <a href="/target/str.go?s=5426:5482#L219">IsInSliceIgnoreCase</a></h2>
			<pre>func IsInSliceIgnoreCase(vals []string, val string) bool</pre>
			<p>
Returns true if lower-case val is in lower-case vals.
</p>

			
		
			
			
			<h2 id="IsLower">func <a href="/target/str.go?s=5589:5616#L224">IsLower</a></h2>
			<pre>func IsLower(s string) bool</pre>
			<p>
Returns true if all Letter-runes in s are lower-case.
</p>

			
		
			
			
			<h2 id="IsOneOf">func <a href="/target/str.go?s=5763:5805#L234">IsOneOf</a></h2>
			<pre>func IsOneOf(s string, all ...string) bool</pre>
			<p>
Returns true if s is in all.
</p>

			
		
			
			
			<h2 id="IsUpper">func <a href="/target/str.go?s=5943:5970#L244">IsUpper</a></h2>
			<pre>func IsUpper(s string) bool</pre>
			<p>
Returns true if all Letter-runes in s are upper-case.
</p>

			
		
			
			
			<h2 id="LettersOnly">func <a href="/target/str.go?s=6160:6199#L254">LettersOnly</a></h2>
			<pre>func LettersOnly(s string) (ret string)</pre>
			<p>
Returns a string representation of s with all non-Letter-runes removed.
</p>

			
		
			
			
			<h2 id="NonEmpties">func <a href="/target/str.go?s=6354:6426#L264">NonEmpties</a></h2>
			<pre>func NonEmpties(breakAtFirstEmpty bool, vals ...string) (slice []string)</pre>
			<p>
Returns a slice that contains the non-empty strings in vals.
</p>

			
		
			
			
			<h2 id="Pluralize">func <a href="/target/str.go?s=6934:6965#L279">Pluralize</a></h2>
			<pre>func Pluralize(s string) string</pre>
			<p>
A most simplistic (not linguistically-correct) English-language pluralizer that may be useful for code or doc generation.
If s ends with &#34;s&#34;, only appends &#34;es&#34;: bus -&gt; buses, mess -&gt; messes
If s ends with &#34;y&#34; (but not &#34;ay&#34;, &#34;ey&#34;, &#34;oy&#34;, &#34;uy&#34; or &#34;iy&#34;), removes &#34;y&#34; and appends &#34;ies&#34;: autonomy -&gt; autonomies, dictionary -&gt; dictionaries etc.
Otherwise, appends &#34;s&#34;.
</p>

			
		
			
			
			<h2 id="PrefixWithSep">func <a href="/target/str.go?s=7240:7288#L290">PrefixWithSep</a></h2>
			<pre>func PrefixWithSep(prefix, sep, v string) string</pre>
			<p>
Prepends prefix + sep to v only if prefix isn&#39;t empty.
</p>

			
		
			
			
			<h2 id="PrependIf">func <a href="/target/str.go?s=7418:7452#L298">PrependIf</a></h2>
			<pre>func PrependIf(s, p string) string</pre>
			<p>
Prepends p to s only if s doesn&#39;t already have that prefix.
</p>

			
		
			
			
			<h2 id="Replace">func <a href="/target/str.go?s=7611:7667#L306">Replace</a></h2>
			<pre>func Replace(str string, repls map[string]string) string</pre>
			<p>
Replaces in str all occurrences of all repls map keys with their associated (mapped) value.
</p>

			
		
			
			
			<h2 id="SafeIdentifier">func <a href="/target/str.go?s=7826:7868#L314">SafeIdentifier</a></h2>
			<pre>func SafeIdentifier(s string) (ret string)</pre>
			<p>
Creates a Pascal-cased &#34;identifier&#34; version of the specified string.
</p>

			
		
			
			
			<h2 id="Split">func <a href="/target/str.go?s=8406:8443#L338">Split</a></h2>
			<pre>func Split(v, s string) (sl []string)</pre>
			<p>
Returns an empty slice is v is emtpy, otherwise like strings.Split()
</p>

			
		
			
			
			<h2 id="StripPrefix">func <a href="/target/str.go?s=8542:8585#L346">StripPrefix</a></h2>
			<pre>func StripPrefix(val, prefix string) string</pre>
			<p>
Strips prefix off val if possible.
</p>

			
		
			
			
			<h2 id="StripSuffix">func <a href="/target/str.go?s=8708:8751#L354">StripSuffix</a></h2>
			<pre>func StripSuffix(val, suffix string) string</pre>
			<p>
Strips suffix off val if possible.
</p>

			
		
			
			
			<h2 id="ToLowerIfUpper">func <a href="/target/str.go?s=9807:9843#L408">ToLowerIfUpper</a></h2>
			<pre>func ToLowerIfUpper(s string) string</pre>
			<p>
Returns the lower-case representation of s only if it is currently fully upper-case as per IsUpper().
</p>

			
		
			
			
			<h2 id="ToUpperIfLower">func <a href="/target/str.go?s=10012:10048#L416">ToUpperIfLower</a></h2>
			<pre>func ToUpperIfLower(s string) string</pre>
			<p>
Returns the upper-case representation of s only if it is currently fully lower-case as per IsLower().
</p>

			
		
			
			
			<h2 id="Without">func <a href="/target/str.go?s=10151:10227#L424">Without</a></h2>
			<pre>func Without(slice []string, keepOrder bool, withoutVals ...string) []string</pre>
			<p>
Removes all withoutVals from slice.
</p>

			
		
		
			
			
			<h2 id="Buffer">type <a href="/target/buf.go?s=85:121#L1">Buffer</a></h2>
			<pre>type Buffer struct {
    bytes.Buffer
}</pre>
			<p>
A convenience wrapper for bytes.Buffer.
</p>


			

			

			

			

			
				
				<h3 id="Buffer.Write">func (*Buffer) <a href="/target/buf.go?s=199:261#L4">Write</a></h3>
				<pre>func (me *Buffer) Write(format string, fmtArgs ...interface{})</pre>
				<p>
Short-hand for bytes.Buffer.WriteString(fmt.Sprintf(format, fmtArgs...))
</p>

				
				
			
				
				<h3 id="Buffer.Writeln">func (*Buffer) <a href="/target/buf.go?s=448:512#L12">Writeln</a></h3>
				<pre>func (me *Buffer) Writeln(format string, fmtArgs ...interface{})</pre>
				<p>
Short-hand for bytes.Buffer.WriteString(fmt.Sprintf(format+&#34;\n&#34;, fmtArgs...))
</p>

				
				
			
		
			
			
			<h2 id="Matcher">type <a href="/target/match.go?s=111:162#L1">Matcher</a></h2>
			<pre>type Matcher struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewMatcher">func <a href="/target/match.go?s=164:213#L5">NewMatcher</a></h3>
				<pre>func NewMatcher(patterns ...string) (me *Matcher)</pre>
				
				
			

			
				
				<h3 id="Matcher.AddPattern">func (*Matcher) <a href="/target/match.go?s=296:335#L13">AddPattern</a></h3>
				<pre>func (me *Matcher) AddPattern(s string)</pre>
				
				
				
			
				
				<h3 id="Matcher.HasWildcardPatterns">func (*Matcher) <a href="/target/match.go?s=636:681#L25">HasWildcardPatterns</a></h3>
				<pre>func (me *Matcher) HasWildcardPatterns() bool</pre>
				
				
				
			
				
				<h3 id="Matcher.IsMatch">func (*Matcher) <a href="/target/match.go?s=829:870#L34">IsMatch</a></h3>
				<pre>func (me *Matcher) IsMatch(s string) bool</pre>
				
				
				
			
				
				<h3 id="Matcher.Match">func (*Matcher) <a href="/target/match.go?s=905:946#L38">Match</a></h3>
				<pre>func (me *Matcher) Match(s string) string</pre>
				
				
				
			
		
		</div>
	

	








		</div></div>
	</body>
</html>