<html>
	<head>
		<title>Package github.com/metaleap/go-util/str</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/metaleap/go-util/str</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/metaleap/go-util/str"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Various line-savers for common string-processing needs.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#AppendUnique">func AppendUnique(sl *[]string, v string)</a></dd>
			
				
				<dd><a href="#ClearMap">func ClearMap(m map[string]string)</a></dd>
			
				
				<dd><a href="#Concat">func Concat(vals ...string) string</a></dd>
			
				
				<dd><a href="#ContainsOnce">func ContainsOnce(str1, str2 string) bool</a></dd>
			
				
				<dd><a href="#Distance">func Distance(s1, s2 string) int</a></dd>
			
				
				<dd><a href="#Equivalent">func Equivalent(one, two []string) bool</a></dd>
			
				
				<dd><a href="#ExtractAllIdentifiers">func ExtractAllIdentifiers(src, prefix string) (identifiers []string)</a></dd>
			
				
				<dd><a href="#ExtractFirstIdentifier">func ExtractFirstIdentifier(src, prefix string, minPos int) (identifier string)</a></dd>
			
				
				<dd><a href="#First">func First(predicate func(s string) bool, step int, vals ...string) string</a></dd>
			
				
				<dd><a href="#FirstNonEmpty">func FirstNonEmpty(vals ...string) (val string)</a></dd>
			
				
				<dd><a href="#HasAnyPrefix">func HasAnyPrefix(s string, prefixes ...string) bool</a></dd>
			
				
				<dd><a href="#HasAnySuffix">func HasAnySuffix(s string, suffixes ...string) bool</a></dd>
			
				
				<dd><a href="#Ifm">func Ifm(cond bool, ifTrue, ifFalse map[string]string) map[string]string</a></dd>
			
				
				<dd><a href="#Ifs">func Ifs(cond bool, ifTrue string, ifFalse string) string</a></dd>
			
				
				<dd><a href="#InSliceAt">func InSliceAt(vals []string, val string) int</a></dd>
			
				
				<dd><a href="#InSliceAtIgnoreCase">func InSliceAtIgnoreCase(vals []string, val string) int</a></dd>
			
				
				<dd><a href="#IndexAny">func IndexAny(s string, seps ...string) (pos int)</a></dd>
			
				
				<dd><a href="#IsAnyInSlice">func IsAnyInSlice(slice []string, vals ...string) bool</a></dd>
			
				
				<dd><a href="#IsAscii">func IsAscii(str string) bool</a></dd>
			
				
				<dd><a href="#IsInSlice">func IsInSlice(vals []string, val string) bool</a></dd>
			
				
				<dd><a href="#IsInSliceIgnoreCase">func IsInSliceIgnoreCase(vals []string, val string) bool</a></dd>
			
				
				<dd><a href="#IsLower">func IsLower(s string) bool</a></dd>
			
				
				<dd><a href="#IsOneOf">func IsOneOf(s string, all ...string) bool</a></dd>
			
				
				<dd><a href="#IsUpper">func IsUpper(s string) bool</a></dd>
			
				
				<dd><a href="#LettersOnly">func LettersOnly(s string) (ret string)</a></dd>
			
				
				<dd><a href="#NonEmpties">func NonEmpties(breakAtFirstEmpty bool, vals ...string) (slice []string)</a></dd>
			
				
				<dd><a href="#Pluralize">func Pluralize(s string) string</a></dd>
			
				
				<dd><a href="#PrefixWithSep">func PrefixWithSep(prefix, sep, v string) string</a></dd>
			
				
				<dd><a href="#PrependIf">func PrependIf(s, p string) string</a></dd>
			
				
				<dd><a href="#Replace">func Replace(str string, repls map[string]string) string</a></dd>
			
				
				<dd><a href="#SafeIdentifier">func SafeIdentifier(s string) (ret string)</a></dd>
			
				
				<dd><a href="#Split">func Split(v, s string) (sl []string)</a></dd>
			
				
				<dd><a href="#StripPrefix">func StripPrefix(val, prefix string) string</a></dd>
			
				
				<dd><a href="#StripSuffix">func StripSuffix(val, suffix string) string</a></dd>
			
				
				<dd><a href="#ToLowerIfUpper">func ToLowerIfUpper(s string) string</a></dd>
			
				
				<dd><a href="#ToUpperIfLower">func ToUpperIfLower(s string) string</a></dd>
			
				
				<dd><a href="#Without">func Without(slice []string, keepOrder bool, withoutVals ...string) []string</a></dd>
			
			
				
				<dd><a href="#Buffer">type Buffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Write">func (me *Buffer) Write(format string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Writeln">func (me *Buffer) Writeln(format string, fmtArgs ...interface{})</a></dd>
				
			
				
				<dd><a href="#Matcher">type Matcher</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Matcher.AddPatterns">func (me *Matcher) AddPatterns(patterns ...string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matcher.HasWildcardPatterns">func (me *Matcher) HasWildcardPatterns() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matcher.IsMatch">func (me *Matcher) IsMatch(s string) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Matcher.Match">func (me *Matcher) Match(s string) string</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/buf.go">buf.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/matcher.go">matcher.go</a>
			
				<a href="/target/str.go">str.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="AppendUnique">func <a href="/target/str.go?s=150:191#L2">AppendUnique</a></h2>
			<pre>func AppendUnique(sl *[]string, v string)</pre>
			<p>
Appends v to sl only if sl does not already contain v.
</p>

			
		
			
			
			<h2 id="ClearMap">func <a href="/target/str.go?s=324:358#L12">ClearMap</a></h2>
			<pre>func ClearMap(m map[string]string)</pre>
			<p>
Sets all values in m to the empty string.
</p>

			
		
			
			
			<h2 id="Concat">func <a href="/target/str.go?s=485:519#L21">Concat</a></h2>
			<pre>func Concat(vals ...string) string</pre>
			<p>
Does a strings.Join() on the specified string values.
</p>

			
		
			
			
			<h2 id="ContainsOnce">func <a href="/target/str.go?s=615:656#L26">ContainsOnce</a></h2>
			<pre>func ContainsOnce(str1, str2 string) bool</pre>
			<p>
Returns true if str2 is contained in str1 exactly once.
</p>

			
		
			
			
			<h2 id="Distance">func <a href="/target/str.go?s=845:877#L35">Distance</a></h2>
			<pre>func Distance(s1, s2 string) int</pre>
			<p>
A simple string-similarity algorithm.
</p>

			
		
			
			
			<h2 id="Equivalent">func <a href="/target/str.go?s=1522:1561#L60">Equivalent</a></h2>
			<pre>func Equivalent(one, two []string) bool</pre>
			<p>
Returns true if one and two contain the same strings, regardless of their respective slice positions.
</p>

			
		
			
			
			<h2 id="ExtractAllIdentifiers">func <a href="/target/str.go?s=1835:1904#L75">ExtractAllIdentifiers</a></h2>
			<pre>func ExtractAllIdentifiers(src, prefix string) (identifiers []string)</pre>
			<p>
Extracts all identifiers (no duplicates, ordered by occurrence) starting with prefix occurring in src.
</p>

			
		
			
			
			<h2 id="ExtractFirstIdentifier">func <a href="/target/str.go?s=2272:2351#L88">ExtractFirstIdentifier</a></h2>
			<pre>func ExtractFirstIdentifier(src, prefix string, minPos int) (identifier string)</pre>
			<p>
Extracts the first occurrence (at or after minPos) of an identifier starting with prefix in src.
</p>

			
		
			
			
			<h2 id="First">func <a href="/target/str.go?s=2821:2895#L104">First</a></h2>
			<pre>func First(predicate func(s string) bool, step int, vals ...string) string</pre>
			<p>
Returns the first string in vals to match the specified predicate.
step: 1 to test all values. A higher value to skip n values after each test. Negative for reverse slice traversal. Or use 0 to get stuck in an infinite loop.
</p>

			
		
			
			
			<h2 id="FirstNonEmpty">func <a href="/target/str.go?s=3128:3175#L116">FirstNonEmpty</a></h2>
			<pre>func FirstNonEmpty(vals ...string) (val string)</pre>
			<p>
Returns the first non-empty string in vals.
</p>

			
		
			
			
			<h2 id="HasAnyPrefix">func <a href="/target/str.go?s=3396:3448#L127">HasAnyPrefix</a></h2>
			<pre>func HasAnyPrefix(s string, prefixes ...string) bool</pre>
			<p>
Returns true if s starts with any one of the specified prefixes.
</p>

			
		
			
			
			<h2 id="HasAnySuffix">func <a href="/target/str.go?s=3627:3679#L137">HasAnySuffix</a></h2>
			<pre>func HasAnySuffix(s string, suffixes ...string) bool</pre>
			<p>
Returns true if s ends with any one of the specified suffixes.
</p>

			
		
			
			
			<h2 id="Ifm">func <a href="/target/str.go?s=3854:3926#L147">Ifm</a></h2>
			<pre>func Ifm(cond bool, ifTrue, ifFalse map[string]string) map[string]string</pre>
			<p>
Returns ifTrue if cond is true, otherwise returns ifFalse.
</p>

			
		
			
			
			<h2 id="Ifs">func <a href="/target/str.go?s=4040:4097#L155">Ifs</a></h2>
			<pre>func Ifs(cond bool, ifTrue string, ifFalse string) string</pre>
			<p>
Returns ifTrue if cond is true, otherwise returns ifFalse.
</p>

			
		
			
			
			<h2 id="InSliceAt">func <a href="/target/str.go?s=4488:4533#L174">InSliceAt</a></h2>
			<pre>func InSliceAt(vals []string, val string) int</pre>
			<p>
Returns the position of val in vals.
</p>

			
		
			
			
			<h2 id="InSliceAtIgnoreCase">func <a href="/target/str.go?s=4673:4728#L184">InSliceAtIgnoreCase</a></h2>
			<pre>func InSliceAtIgnoreCase(vals []string, val string) int</pre>
			<p>
Returns the position of lower-case val in lower-case vals.
</p>

			
		
			
			
			<h2 id="IndexAny">func <a href="/target/str.go?s=4244:4293#L163">IndexAny</a></h2>
			<pre>func IndexAny(s string, seps ...string) (pos int)</pre>
			<p>
For all seps, computes the index of first occurrence in s, then returns the smallest index.
</p>

			
		
			
			
			<h2 id="IsAnyInSlice">func <a href="/target/str.go?s=4934:4988#L195">IsAnyInSlice</a></h2>
			<pre>func IsAnyInSlice(slice []string, vals ...string) bool</pre>
			<p>
Returns whether one of the specified vals is contained in slice.
</p>

			
		
			
			
			<h2 id="IsAscii">func <a href="/target/str.go?s=5273:5302#L213">IsAscii</a></h2>
			<pre>func IsAscii(str string) bool</pre>
			<p>
Returns true if str is ASCII-compatible.
</p>

			
		
			
			
			<h2 id="IsInSlice">func <a href="/target/str.go?s=5432:5478#L223">IsInSlice</a></h2>
			<pre>func IsInSlice(vals []string, val string) bool</pre>
			<p>
Returns true if val is in vals.
</p>

			
		
			
			
			<h2 id="IsInSliceIgnoreCase">func <a href="/target/str.go?s=5575:5631#L228">IsInSliceIgnoreCase</a></h2>
			<pre>func IsInSliceIgnoreCase(vals []string, val string) bool</pre>
			<p>
Returns true if lower-case val is in lower-case vals.
</p>

			
		
			
			
			<h2 id="IsLower">func <a href="/target/str.go?s=5738:5765#L233">IsLower</a></h2>
			<pre>func IsLower(s string) bool</pre>
			<p>
Returns true if all Letter-runes in s are lower-case.
</p>

			
		
			
			
			<h2 id="IsOneOf">func <a href="/target/str.go?s=5912:5954#L243">IsOneOf</a></h2>
			<pre>func IsOneOf(s string, all ...string) bool</pre>
			<p>
Returns true if s is in all.
</p>

			
		
			
			
			<h2 id="IsUpper">func <a href="/target/str.go?s=6092:6119#L253">IsUpper</a></h2>
			<pre>func IsUpper(s string) bool</pre>
			<p>
Returns true if all Letter-runes in s are upper-case.
</p>

			
		
			
			
			<h2 id="LettersOnly">func <a href="/target/str.go?s=6309:6348#L263">LettersOnly</a></h2>
			<pre>func LettersOnly(s string) (ret string)</pre>
			<p>
Returns a string representation of s with all non-Letter-runes removed.
</p>

			
		
			
			
			<h2 id="NonEmpties">func <a href="/target/str.go?s=6503:6575#L273">NonEmpties</a></h2>
			<pre>func NonEmpties(breakAtFirstEmpty bool, vals ...string) (slice []string)</pre>
			<p>
Returns a slice that contains the non-empty strings in vals.
</p>

			
		
			
			
			<h2 id="Pluralize">func <a href="/target/str.go?s=7083:7114#L288">Pluralize</a></h2>
			<pre>func Pluralize(s string) string</pre>
			<p>
A most simplistic (not linguistically-correct) English-language pluralizer that may be useful for code or doc generation.
If s ends with &#34;s&#34;, only appends &#34;es&#34;: bus -&gt; buses, mess -&gt; messes
If s ends with &#34;y&#34; (but not &#34;ay&#34;, &#34;ey&#34;, &#34;oy&#34;, &#34;uy&#34; or &#34;iy&#34;), removes &#34;y&#34; and appends &#34;ies&#34;: autonomy -&gt; autonomies, dictionary -&gt; dictionaries etc.
Otherwise, appends &#34;s&#34;.
</p>

			
		
			
			
			<h2 id="PrefixWithSep">func <a href="/target/str.go?s=7389:7437#L299">PrefixWithSep</a></h2>
			<pre>func PrefixWithSep(prefix, sep, v string) string</pre>
			<p>
Prepends prefix + sep to v only if prefix isn&#39;t empty.
</p>

			
		
			
			
			<h2 id="PrependIf">func <a href="/target/str.go?s=7567:7601#L307">PrependIf</a></h2>
			<pre>func PrependIf(s, p string) string</pre>
			<p>
Prepends p to s only if s doesn&#39;t already have that prefix.
</p>

			
		
			
			
			<h2 id="Replace">func <a href="/target/str.go?s=7760:7816#L315">Replace</a></h2>
			<pre>func Replace(str string, repls map[string]string) string</pre>
			<p>
Replaces in str all occurrences of all repls map keys with their associated (mapped) value.
</p>

			
		
			
			
			<h2 id="SafeIdentifier">func <a href="/target/str.go?s=7975:8017#L323">SafeIdentifier</a></h2>
			<pre>func SafeIdentifier(s string) (ret string)</pre>
			<p>
Creates a Pascal-cased &#34;identifier&#34; version of the specified string.
</p>

			
		
			
			
			<h2 id="Split">func <a href="/target/str.go?s=8555:8592#L347">Split</a></h2>
			<pre>func Split(v, s string) (sl []string)</pre>
			<p>
Returns an empty slice is v is emtpy, otherwise like strings.Split()
</p>

			
		
			
			
			<h2 id="StripPrefix">func <a href="/target/str.go?s=8691:8734#L355">StripPrefix</a></h2>
			<pre>func StripPrefix(val, prefix string) string</pre>
			<p>
Strips prefix off val if possible.
</p>

			
		
			
			
			<h2 id="StripSuffix">func <a href="/target/str.go?s=8857:8900#L363">StripSuffix</a></h2>
			<pre>func StripSuffix(val, suffix string) string</pre>
			<p>
Strips suffix off val if possible.
</p>

			
		
			
			
			<h2 id="ToLowerIfUpper">func <a href="/target/str.go?s=9956:9992#L417">ToLowerIfUpper</a></h2>
			<pre>func ToLowerIfUpper(s string) string</pre>
			<p>
Returns the lower-case representation of s only if it is currently fully upper-case as per IsUpper().
</p>

			
		
			
			
			<h2 id="ToUpperIfLower">func <a href="/target/str.go?s=10161:10197#L425">ToUpperIfLower</a></h2>
			<pre>func ToUpperIfLower(s string) string</pre>
			<p>
Returns the upper-case representation of s only if it is currently fully lower-case as per IsLower().
</p>

			
		
			
			
			<h2 id="Without">func <a href="/target/str.go?s=10300:10376#L433">Without</a></h2>
			<pre>func Without(slice []string, keepOrder bool, withoutVals ...string) []string</pre>
			<p>
Removes all withoutVals from slice.
</p>

			
		
		
			
			
			<h2 id="Buffer">type <a href="/target/buf.go?s=85:121#L1">Buffer</a></h2>
			<pre>type Buffer struct {
    bytes.Buffer
}</pre>
			<p>
A convenience wrapper for bytes.Buffer.
</p>


			

			

			

			

			
				
				<h3 id="Buffer.Write">func (*Buffer) <a href="/target/buf.go?s=199:261#L4">Write</a></h3>
				<pre>func (me *Buffer) Write(format string, fmtArgs ...interface{})</pre>
				<p>
Short-hand for bytes.Buffer.WriteString(fmt.Sprintf(format, fmtArgs...))
</p>

				
				
			
				
				<h3 id="Buffer.Writeln">func (*Buffer) <a href="/target/buf.go?s=448:512#L12">Writeln</a></h3>
				<pre>func (me *Buffer) Writeln(format string, fmtArgs ...interface{})</pre>
				<p>
Short-hand for bytes.Buffer.WriteString(fmt.Sprintf(format+&#34;\n&#34;, fmtArgs...))
</p>

				
				
			
		
			
			
			<h2 id="Matcher">type <a href="/target/matcher.go?s=259:309#L3">Matcher</a></h2>
			<pre>type Matcher struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Matches a string against &#34;simple-patterns&#34;.
Simple-patterns are strings that can have *-wildcards only at the beginning, at the end, or both.
</p>


			

			

			

			

			
				
				<h3 id="Matcher.AddPatterns">func (*Matcher) <a href="/target/matcher.go?s=348:398#L8">AddPatterns</a></h3>
				<pre>func (me *Matcher) AddPatterns(patterns ...string)</pre>
				<p>
Adds the specified pattern to me.
</p>

				
				
			
				
				<h3 id="Matcher.HasWildcardPatterns">func (*Matcher) <a href="/target/matcher.go?s=928:973#L26">HasWildcardPatterns</a></h3>
				<pre>func (me *Matcher) HasWildcardPatterns() bool</pre>
				<p>
Returns whether any of the patterns specified for this Matcher contains a *-wildcard.
</p>

				
				
			
				
				<h3 id="Matcher.IsMatch">func (*Matcher) <a href="/target/matcher.go?s=1254:1295#L36">IsMatch</a></h3>
				<pre>func (me *Matcher) IsMatch(s string) bool</pre>
				<p>
Convenience short-hand that informs whether Match(s) returns a non-empty result value.
</p>

				
				
			
				
				<h3 id="Matcher.Match">func (*Matcher) <a href="/target/matcher.go?s=1462:1503#L42">Match</a></h3>
				<pre>func (me *Matcher) Match(s string) string</pre>
				<p>
Matches s against all patterns in me.
Returns the first pattern (minus wildcards) that matches s, or &#34;&#34; if there is no match.
</p>

				
				
			
		
		</div>
	

	








		</div></div>
	</body>
</html>