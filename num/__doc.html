<html>
	<head>
		<title>Package github.com/metaleap/go-util/num</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/metaleap/go-util/num</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/metaleap/go-util/num"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
A few maths-helpers, plus vectors, matrices and quaternions.
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#AllEqual">func AllEqual(test float64, vals ...float64) bool</a></dd>
			
				
				<dd><a href="#Clamp">func Clamp(val, c0, c1 float64) float64</a></dd>
			
				
				<dd><a href="#DegToRad">func DegToRad(deg float64) float64</a></dd>
			
				
				<dd><a href="#Din1">func Din1(val, max float64) float64</a></dd>
			
				
				<dd><a href="#Fin1">func Fin1(val, max float32) float32</a></dd>
			
				
				<dd><a href="#IsEven">func IsEven(val int) bool</a></dd>
			
				
				<dd><a href="#IsInt">func IsInt(val float64) bool</a></dd>
			
				
				<dd><a href="#IsMod0">func IsMod0(v, m int) bool</a></dd>
			
				
				<dd><a href="#Mat3Identities">func Mat3Identities(mats ...*Mat3)</a></dd>
			
				
				<dd><a href="#Mat4Identities">func Mat4Identities(mats ...*Mat4)</a></dd>
			
				
				<dd><a href="#Mini">func Mini(v1, v2 int) int</a></dd>
			
				
				<dd><a href="#Mix">func Mix(x, y, a float64) float64</a></dd>
			
				
				<dd><a href="#Nextafter32">func Nextafter32(x, y float64) (r float64)</a></dd>
			
				
				<dd><a href="#RadToDeg">func RadToDeg(rad float64) float64</a></dd>
			
				
				<dd><a href="#Round">func Round(v float64) (fint float64)</a></dd>
			
				
				<dd><a href="#Saturate">func Saturate(v float64) float64</a></dd>
			
				
				<dd><a href="#Sign">func Sign(v float64) (sign float64)</a></dd>
			
				
				<dd><a href="#Step">func Step(edge, x float64) (step int)</a></dd>
			
			
				
				<dd><a href="#Mat3">type Mat3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat3Identity">func NewMat3Identity() (mat *Mat3)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat3.Identity">func (me *Mat3) Identity()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat3.Transpose">func (me *Mat3) Transpose()</a></dd>
				
			
				
				<dd><a href="#Mat4">type Mat4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Add">func NewMat4Add(a, b *Mat4) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Frustum">func NewMat4Frustum(left, right, bottom, top, near, far float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Identity">func NewMat4Identity() (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Lookat">func NewMat4Lookat(eyePos, lookTarget, upVec *Vec3) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Mult1">func NewMat4Mult1(m *Mat4, v float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Mult4">func NewMat4Mult4(one, two *Mat4) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4MultN">func NewMat4MultN(mats ...*Mat4) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Orient">func NewMat4Orient(lookTarget, worldUp *Vec3) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Perspective">func NewMat4Perspective(fovY, aspect, near, far float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4RotationX">func NewMat4RotationX(rad float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4RotationY">func NewMat4RotationY(rad float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4RotationZ">func NewMat4RotationZ(rad float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Scaling">func NewMat4Scaling(vec *Vec3) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Sub">func NewMat4Sub(a, b *Mat4) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Translation">func NewMat4Translation(vec *Vec3) (mat *Mat4)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Abs">func (me *Mat4) Abs() (abs *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Add">func (me *Mat4) Add(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Clear">func (me *Mat4) Clear()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Clone">func (me *Mat4) Clone() (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.CopyFrom">func (me *Mat4) CopyFrom(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.CopyTo">func (me *Mat4) CopyTo(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Frustum">func (me *Mat4) Frustum(left, right, bottom, top, near, far float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Identity">func (me *Mat4) Identity()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Lookat">func (me *Mat4) Lookat(eyePos, lookTarget, upVec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Mult1">func (me *Mat4) Mult1(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Orient">func (me *Mat4) Orient(lookTarget, worldUp *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Perspective">func (me *Mat4) Perspective(fovYDeg, a, n, f float64) (fovYRadHalf float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.RotationX">func (me *Mat4) RotationX(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.RotationY">func (me *Mat4) RotationY(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.RotationZ">func (me *Mat4) RotationZ(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Scaling">func (me *Mat4) Scaling(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.SetFromMult4">func (me *Mat4) SetFromMult4(one, two *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.SetFromMultN">func (me *Mat4) SetFromMultN(mats ...*Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.SetFromTransposeOf">func (me *Mat4) SetFromTransposeOf(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Sub">func (me *Mat4) Sub(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.ToInverseMat3">func (me *Mat4) ToInverseMat3(mat *Mat3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Translation">func (me *Mat4) Translation(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Transposed">func (me *Mat4) Transposed() (mat *Mat4)</a></dd>
				
			
				
				<dd><a href="#Vec2">type Vec2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Div">func (me *Vec2) Div(vec *Vec2) *Vec2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Dot">func (me *Vec2) Dot(vec *Vec2) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Length">func (me *Vec2) Length() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Magnitude">func (me *Vec2) Magnitude() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Mult">func (me *Vec2) Mult(vec *Vec2) *Vec2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Normalize">func (me *Vec2) Normalize()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Normalized">func (me *Vec2) Normalized() *Vec2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.NormalizedScaled">func (me *Vec2) NormalizedScaled(factor float64) (vec *Vec2)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Scale">func (me *Vec2) Scale(factor float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Scaled">func (me *Vec2) Scaled(factor float64) *Vec2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.String">func (me *Vec2) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Sub">func (me *Vec2) Sub(vec *Vec2) *Vec2</a></dd>
				
			
				
				<dd><a href="#Vec3">type Vec3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AbsMax">func (me *Vec3) AbsMax() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Add">func (me *Vec3) Add(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Add1">func (me *Vec3) Add1(val float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Add3">func (me *Vec3) Add3(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AddTo">func (me *Vec3) AddTo(vec *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AllEqual">func (me *Vec3) AllEqual(val float64) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AllGreaterOrEqual">func (me *Vec3) AllGreaterOrEqual(vec *Vec3) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AllInRange">func (me *Vec3) AllInRange(min, max float64) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AllInside">func (me *Vec3) AllInside(min, max *Vec3) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AllLessOrEqual">func (me *Vec3) AllLessOrEqual(vec *Vec3) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Clamp">func (me *Vec3) Clamp(min, max *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Clear">func (me *Vec3) Clear()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Cross">func (me *Vec3) Cross(vec *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.CrossNormalized">func (me *Vec3) CrossNormalized(vec *Vec3) (r *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.DistanceFrom">func (me *Vec3) DistanceFrom(vec *Vec3) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.DistanceFromZero">func (me *Vec3) DistanceFromZero() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Div">func (me *Vec3) Div(vec *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Div1">func (me *Vec3) Div1(val float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Dot">func (me *Vec3) Dot(vec *Vec3) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.DotSub">func (me *Vec3) DotSub(vec1, vec2 *Vec3) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Equals">func (me *Vec3) Equals(vec *Vec3) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Inv">func (me *Vec3) Inv() *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Length">func (me *Vec3) Length() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Magnitude">func (me *Vec3) Magnitude() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.MakeFinite">func (me *Vec3) MakeFinite(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.ManhattanDistanceFrom">func (me *Vec3) ManhattanDistanceFrom(vec *Vec3) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Max">func (me *Vec3) Max() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Min">func (me *Vec3) Min() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Mult">func (me *Vec3) Mult(vec *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Negate">func (me *Vec3) Negate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Negated">func (me *Vec3) Negated() *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Normalize">func (me *Vec3) Normalize()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Normalized">func (me *Vec3) Normalized() (vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.NormalizedScaled">func (me *Vec3) NormalizedScaled(factor float64) (vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.RotateDeg">func (me *Vec3) RotateDeg(angleDeg float64, axis *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.RotateRad">func (me *Vec3) RotateRad(angleRad float64, axis *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Scale">func (me *Vec3) Scale(factor float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.ScaleAdd">func (me *Vec3) ScaleAdd(factor, add *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Scaled">func (me *Vec3) Scaled(factor float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.ScaledAdded">func (me *Vec3) ScaledAdded(factor float64, add *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Set">func (me *Vec3) Set(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFrom">func (me *Vec3) SetFrom(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromAdd">func (me *Vec3) SetFromAdd(vec1, vec2 *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromAddAdd">func (me *Vec3) SetFromAddAdd(a, b, c *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromAddMult">func (me *Vec3) SetFromAddMult(add, mul1, mul2 *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromAddScaled">func (me *Vec3) SetFromAddScaled(vec1, vec2 *Vec3, mul float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromAddSub">func (me *Vec3) SetFromAddSub(a, b, c *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromCos">func (me *Vec3) SetFromCos(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromCross">func (me *Vec3) SetFromCross(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromCrossOf">func (me *Vec3) SetFromCrossOf(one, two *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromDegToRad">func (me *Vec3) SetFromDegToRad(deg *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromEpsilon32">func (me *Vec3) SetFromEpsilon32()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromEpsilon64">func (me *Vec3) SetFromEpsilon64()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromInv">func (me *Vec3) SetFromInv(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromMult">func (me *Vec3) SetFromMult(v1, v2 *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromNormalized">func (me *Vec3) SetFromNormalized(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromRotation">func (me *Vec3) SetFromRotation(pos, rotCos, rotSin *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromScaled">func (me *Vec3) SetFromScaled(vec *Vec3, mul float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromScaledSub">func (me *Vec3) SetFromScaledSub(vec1, vec2 *Vec3, mul float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSin">func (me *Vec3) SetFromSin(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromStep">func (me *Vec3) SetFromStep(edge float64, vec, v0, v1 *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSub">func (me *Vec3) SetFromSub(vec1, vec2 *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSubAdd">func (me *Vec3) SetFromSubAdd(a, b, c *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSubMult">func (me *Vec3) SetFromSubMult(sub1, sub2, mul *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSubScaled">func (me *Vec3) SetFromSubScaled(v1, v2 *Vec3, v2Scale float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSubSub">func (me *Vec3) SetFromSubSub(a, b, c *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSwapSign">func (me *Vec3) SetFromSwapSign(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetToMax">func (me *Vec3) SetToMax()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetToMin">func (me *Vec3) SetToMin()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Sign">func (me *Vec3) Sign() *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.String">func (me *Vec3) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Sub">func (me *Vec3) Sub(vec *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubDivMult">func (me *Vec3) SubDivMult(sub, div, mul *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubDot">func (me *Vec3) SubDot(vec *Vec3) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubFloorDivMult">func (me *Vec3) SubFloorDivMult(floorDiv, mul float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubFrom">func (me *Vec3) SubFrom(val float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubScaled">func (me *Vec3) SubScaled(vec *Vec3, val float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubVec">func (me *Vec3) SubVec(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Times">func (me *Vec3) Times(x, y, z float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.TransformCoord">func (me *Vec3) TransformCoord(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.TransformNormal">func (me *Vec3) TransformNormal(mat *Mat4, absMat bool)</a></dd>
				
			
				
				<dd><a href="#Vec4">type Vec4</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.Clone">func (me *Vec4) Clone() (q *Vec4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.Conjugate">func (me *Vec4) Conjugate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.Conjugated">func (me *Vec4) Conjugated() (v *Vec4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.Length">func (me *Vec4) Length() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.Magnitude">func (me *Vec4) Magnitude() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.MultMat4Vec3">func (me *Vec4) MultMat4Vec3(mat *Mat4, vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.MultMat4Vec4">func (me *Vec4) MultMat4Vec4(mat *Mat4, vec *Vec4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.Normalize">func (me *Vec4) Normalize()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.NormalizeFrom">func (me *Vec4) NormalizeFrom(magnitude float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.Normalized">func (me *Vec4) Normalized() *Vec4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.Scale">func (me *Vec4) Scale(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.SetFromConjugated">func (me *Vec4) SetFromConjugated(c *Vec4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.SetFromMult">func (me *Vec4) SetFromMult(l, r *Vec4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.SetFromMult3">func (me *Vec4) SetFromMult3(q *Vec4, v *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.SetFromMultMat4">func (me *Vec4) SetFromMultMat4(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec4.String">func (me *Vec4) String() string</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/mat3.go">mat3.go</a>
			
				<a href="/target/mat4.go">mat4.go</a>
			
				<a href="/target/num.go">num.go</a>
			
				<a href="/target/vec2.go">vec2.go</a>
			
				<a href="/target/vec3.go">vec3.go</a>
			
				<a href="/target/vec4.go">vec4.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    <span id="PiDiv180">PiDiv180</span>  = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Pi">Pi</a> / 180
    <span id="PiDiv360">PiDiv360</span>  = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Pi">Pi</a> / 360
    <span id="PiHalfDiv">PiHalfDiv</span> = 0.5 / <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Pi">Pi</a>
)</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span id="Infinity">Infinity</span>    = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Inf">Inf</a>(1)
    <span id="NegInfinity">NegInfinity</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Inf">Inf</a>(-1)

    <span id="Epsilon32">Epsilon32</span> = <a href="#Nextafter32">Nextafter32</a>(1, <a href="#Infinity">Infinity</a>) - 1
    <span id="Epsilon64">Epsilon64</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#Nextafter">Nextafter</a>(1, <a href="#Infinity">Infinity</a>) - 1
)</pre>
				
			
		
		
			
			
			<h2 id="AllEqual">func <a href="/target/num.go?s=325:374#L13">AllEqual</a></h2>
			<pre>func AllEqual(test <a href="/pkg/builtin/#float64">float64</a>, vals ...<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if all vals equal test.
</p>

			
		
			
			
			<h2 id="Clamp">func <a href="/target/num.go?s=505:544#L23">Clamp</a></h2>
			<pre>func Clamp(val, c0, c1 <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Clamps val between c0 and c1
</p>

			
		
			
			
			<h2 id="DegToRad">func <a href="/target/num.go?s=711:745#L35">DegToRad</a></h2>
			<pre>func DegToRad(deg <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Converts the specified degrees to radians.
</p>

			
		
			
			
			<h2 id="Din1">func <a href="/target/num.go?s=881:916#L41">Din1</a></h2>
			<pre>func Din1(val, max <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Returns the &#34;normalized ratio&#34; of val to max.
Example: for max = 900 and val = 300, returns 0.33333.
</p>

			
		
			
			
			<h2 id="Fin1">func <a href="/target/num.go?s=1053:1088#L47">Fin1</a></h2>
			<pre>func Fin1(val, max <a href="/pkg/builtin/#float32">float32</a>) <a href="/pkg/builtin/#float32">float32</a></pre>
			<p>
Returns the &#34;normalized ratio&#34; of val to max.
Example: for max = 900 and val = 300, returns 0.33333.
</p>

			
		
			
			
			<h2 id="IsEven">func <a href="/target/num.go?s=1975:2000#L74">IsEven</a></h2>
			<pre>func IsEven(val <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if val is even
</p>

			
		
			
			
			<h2 id="IsInt">func <a href="/target/num.go?s=2092:2120#L79">IsInt</a></h2>
			<pre>func IsInt(val <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if val represents an integer
</p>

			
		
			
			
			<h2 id="IsMod0">func <a href="/target/num.go?s=2209:2235#L85">IsMod0</a></h2>
			<pre>func IsMod0(v, m <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if math.Mod(v, m) is zero
</p>

			
		
			
			
			<h2 id="Mat3Identities">func <a href="/target/mat3.go?s=760:794#L25">Mat3Identities</a></h2>
			<pre>func Mat3Identities(mats ...*<a href="#Mat3">Mat3</a>)</pre>
			<p>
Calls the Identity() method on all specified mats.
</p>

			
		
			
			
			<h2 id="Mat4Identities">func <a href="/target/mat4.go?s=10647:10681#L234">Mat4Identities</a></h2>
			<pre>func Mat4Identities(mats ...*<a href="#Mat4">Mat4</a>)</pre>
			<p>
Calls the Identity() method on all specified mats.
</p>

			
		
			
			
			<h2 id="Mini">func <a href="/target/num.go?s=2667:2692#L112">Mini</a></h2>
			<pre>func Mini(v1, v2 <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Returns the smaller of two values.
</p>

			
		
			
			
			<h2 id="Mix">func <a href="/target/num.go?s=2831:2864#L120">Mix</a></h2>
			<pre>func Mix(x, y, a <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Returns x if a is 0, y if a is 1, or a corresponding mix of both if a is between 0 and 1.
</p>

			
		
			
			
			<h2 id="Nextafter32">func <a href="/target/num.go?s=2981:3023#L125">Nextafter32</a></h2>
			<pre>func Nextafter32(x, y <a href="/pkg/builtin/#float64">float64</a>) (r <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
<a href="https://groups.google.com/forum/?fromgroups=#">https://groups.google.com/forum/?fromgroups=#</a>!topic/golang-nuts/dVtKN8QLUNM
</p>

			
		
			
			
			<h2 id="RadToDeg">func <a href="/target/num.go?s=3519:3553#L144">RadToDeg</a></h2>
			<pre>func RadToDeg(rad <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Converts the specified radians to degrees.
</p>

			
		
			
			
			<h2 id="Round">func <a href="/target/num.go?s=3699:3735#L149">Round</a></h2>
			<pre>func Round(v <a href="/pkg/builtin/#float64">float64</a>) (fint <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Returns (the equivalent of) math.Ceil(v) if fraction &gt;= 0.5, otherwise returns (the equivalent of) math.Floor(v).
</p>

			
		
			
			
			<h2 id="Saturate">func <a href="/target/num.go?s=3853:3885#L158">Saturate</a></h2>
			<pre>func Saturate(v <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Clamps v between 0 and 1.
</p>

			
		
			
			
			<h2 id="Sign">func <a href="/target/num.go?s=3985:4020#L163">Sign</a></h2>
			<pre>func Sign(v <a href="/pkg/builtin/#float64">float64</a>) (sign <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Returns -1 if v is negative, 1 if v is positive, or 0 if v is zero.
</p>

			
		
			
			
			<h2 id="Step">func <a href="/target/num.go?s=4165:4202#L174">Step</a></h2>
			<pre>func Step(edge, x <a href="/pkg/builtin/#float64">float64</a>) (step <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Returns 0 if x &lt; edge, otherwise returns 1.
</p>

			
		
		
			
			
			<h2 id="Mat3">type <a href="/target/mat3.go?s=42:62#L1">Mat3</a></h2>
			<pre>type Mat3 [9]<a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Represents a 3x3 matrix.
</p>


			

			
				<pre>var (
    <span class="comment">//	The 3x3 identity matrix.</span>
    <span id="Mat3Identity">Mat3Identity</span> <a href="#Mat3">Mat3</a>
)</pre>
				
			

			

			
				
				<h3 id="NewMat3Identity">func <a href="/target/mat3.go?s=886:920#L32">NewMat3Identity</a></h3>
				<pre>func NewMat3Identity() (mat *<a href="#Mat3">Mat3</a>)</pre>
				<p>
Returns a new 3x3 identity matrix.
</p>

				
			

			
				
				<h3 id="Mat3.Identity">func (*Mat3) <a href="/target/mat3.go?s=362:388#L8">Identity</a></h3>
				<pre>func (me *<a href="#Mat3">Mat3</a>) Identity()</pre>
				<p>
Sets this 3x3 matrix to Mat3Identity.
</p>

				
				
			
				
				<h3 id="Mat3.Transpose">func (*Mat3) <a href="/target/mat3.go?s=445:472#L13">Transpose</a></h3>
				<pre>func (me *<a href="#Mat3">Mat3</a>) Transpose()</pre>
				<p>
Transposes this 3x3 matrix.
</p>

				
				
			
		
			
			
			<h2 id="Mat4">type <a href="/target/mat4.go?s=75:96#L1">Mat4</a></h2>
			<pre>type Mat4 [16]<a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Represents a 4x4 column-major matrix.
</p>


			

			
				<pre>var (
    <span class="comment">//	The 4x4 identity matrix.</span>
    <span id="Mat4Identity">Mat4Identity</span> <a href="#Mat4">Mat4</a>
)</pre>
				
			

			

			
				
				<h3 id="NewMat4Add">func <a href="/target/mat4.go?s=10805:10844#L241">NewMat4Add</a></h3>
				<pre>func NewMat4Add(a, b *<a href="#Mat4">Mat4</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix representing the result of adding a to b.
</p>

				
			
				
				<h3 id="NewMat4Frustum">func <a href="/target/mat4.go?s=11265:11341#L251">NewMat4Frustum</a></h3>
				<pre>func NewMat4Frustum(left, right, bottom, top, near, far <a href="/pkg/builtin/#float64">float64</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix representing the specified frustum.
</p>

				
			
				
				<h3 id="NewMat4Identity">func <a href="/target/mat4.go?s=11484:11518#L258">NewMat4Identity</a></h3>
				<pre>func NewMat4Identity() (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix representing the identity matrix.
</p>

				
			
				
				<h3 id="NewMat4Lookat">func <a href="/target/mat4.go?s=11888:11951#L272">NewMat4Lookat</a></h3>
				<pre>func NewMat4Lookat(eyePos, lookTarget, upVec *<a href="#Vec3">Vec3</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix representing the &#34;look-at matrix&#34; computed from the specified vectors.
</p>

				
			
				
				<h3 id="NewMat4Mult1">func <a href="/target/mat4.go?s=12112:12161#L279">NewMat4Mult1</a></h3>
				<pre>func NewMat4Mult1(m *<a href="#Mat4">Mat4</a>, v <a href="/pkg/builtin/#float64">float64</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix representing the result of multiplying all values in m with v.
</p>

				
			
				
				<h3 id="NewMat4Mult4">func <a href="/target/mat4.go?s=12548:12593#L289">NewMat4Mult4</a></h3>
				<pre>func NewMat4Mult4(one, two *<a href="#Mat4">Mat4</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix that represents the result of multiplying one with two.
</p>

				
			
				
				<h3 id="NewMat4MultN">func <a href="/target/mat4.go?s=12749:12793#L296">NewMat4MultN</a></h3>
				<pre>func NewMat4MultN(mats ...*<a href="#Mat4">Mat4</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix that represents the result of multiplying all mats with one another.
</p>

				
			
				
				<h3 id="NewMat4Orient">func <a href="/target/mat4.go?s=11668:11725#L265">NewMat4Orient</a></h3>
				<pre>func NewMat4Orient(lookTarget, worldUp *<a href="#Vec3">Vec3</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix representing the &#34;orientation matrix&#34; computed from the specified vectors.
</p>

				
			
				
				<h3 id="NewMat4Perspective">func <a href="/target/mat4.go?s=12940:13008#L303">NewMat4Perspective</a></h3>
				<pre>func NewMat4Perspective(fovY, aspect, near, far <a href="/pkg/builtin/#float64">float64</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix that represents the specified perspective-projection matrix.
</p>

				
			
				
				<h3 id="NewMat4RotationX">func <a href="/target/mat4.go?s=13293:13339#L316">NewMat4RotationX</a></h3>
				<pre>func NewMat4RotationX(rad <a href="/pkg/builtin/#float64">float64</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix that representing a rotation of rad radians around the X asis.
</p>

				
			
				
				<h3 id="NewMat4RotationY">func <a href="/target/mat4.go?s=13481:13527#L323">NewMat4RotationY</a></h3>
				<pre>func NewMat4RotationY(rad <a href="/pkg/builtin/#float64">float64</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix that representing a rotation of rad radians around the Y asis.
</p>

				
			
				
				<h3 id="NewMat4RotationZ">func <a href="/target/mat4.go?s=13669:13715#L330">NewMat4RotationZ</a></h3>
				<pre>func NewMat4RotationZ(rad <a href="/pkg/builtin/#float64">float64</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix that representing a rotation of rad radians around the Z asis.
</p>

				
			
				
				<h3 id="NewMat4Scaling">func <a href="/target/mat4.go?s=13846:13888#L337">NewMat4Scaling</a></h3>
				<pre>func NewMat4Scaling(vec *<a href="#Vec3">Vec3</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix that represents a transformation of &#34;scale by vec&#34;.
</p>

				
			
				
				<h3 id="NewMat4Sub">func <a href="/target/mat4.go?s=13992:14031#L344">NewMat4Sub</a></h3>
				<pre>func NewMat4Sub(a, b *<a href="#Mat4">Mat4</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix that represents a minus b.
</p>

				
			
				
				<h3 id="NewMat4Translation">func <a href="/target/mat4.go?s=14472:14518#L354">NewMat4Translation</a></h3>
				<pre>func NewMat4Translation(vec *<a href="#Vec3">Vec3</a>) (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a new 4x4 matrix that represents a transformation of &#34;translate by vec&#34;.
</p>

				
			

			
				
				<h3 id="Mat4.Abs">func (*Mat4) <a href="/target/mat4.go?s=610:643#L15">Abs</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Abs() (abs *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a Mat4 where each cell represents the absolute value of the corresponding cell in me.
</p>

				
				
			
				
				<h3 id="Mat4.Add">func (*Mat4) <a href="/target/mat4.go?s=769:799#L24">Add</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Add(mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Adds mat to this 4x4 matrix.
</p>

				
				
			
				
				<h3 id="Mat4.Clear">func (*Mat4) <a href="/target/mat4.go?s=1190:1213#L32">Clear</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Clear()</pre>
				<p>
Zeroes this 4x4 matrix.
</p>

				
				
			
				
				<h3 id="Mat4.Clone">func (*Mat4) <a href="/target/mat4.go?s=1284:1319#L37">Clone</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Clone() (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns a pointer to a newly allocated copy of me.
</p>

				
				
			
				
				<h3 id="Mat4.CopyFrom">func (*Mat4) <a href="/target/mat4.go?s=1417:1452#L44">CopyFrom</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) CopyFrom(mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Sets this 4x4 matrix to the same values as mat.
</p>

				
				
			
				
				<h3 id="Mat4.CopyTo">func (*Mat4) <a href="/target/mat4.go?s=1521:1554#L49">CopyTo</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) CopyTo(mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Sets mat to the same values as this 4x4 matrix.
</p>

				
				
			
				
				<h3 id="Mat4.Frustum">func (*Mat4) <a href="/target/mat4.go?s=1632:1700#L54">Frustum</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Frustum(left, right, bottom, top, near, far <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets this 4x4 matrix to represent the specified frustum.
</p>

				
				
			
				
				<h3 id="Mat4.Identity">func (*Mat4) <a href="/target/mat4.go?s=2092:2118#L62">Identity</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Identity()</pre>
				<p>
Sets this 4x4 matrix to Mat4Identity.
</p>

				
				
			
				
				<h3 id="Mat4.Lookat">func (*Mat4) <a href="/target/mat4.go?s=2216:2271#L67">Lookat</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Lookat(eyePos, lookTarget, upVec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets me to the &#34;look-at matrix&#34; computed from the specified vectors.
</p>

				
				
			
				
				<h3 id="Mat4.Mult1">func (*Mat4) <a href="/target/mat4.go?s=3123:3155#L92">Mult1</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Mult1(v <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Multiplies all values in this 4x4 matrix with v.
</p>

				
				
			
				
				<h3 id="Mat4.Orient">func (*Mat4) <a href="/target/mat4.go?s=2665:2714#L80">Orient</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Orient(lookTarget, worldUp *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets me to the &#34;orientation matrix&#34; computed from the specified vectors.
</p>

				
				
			
				
				<h3 id="Mat4.Perspective">func (*Mat4) <a href="/target/mat4.go?s=3604:3679#L101">Perspective</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Perspective(fovYDeg, a, n, f <a href="/pkg/builtin/#float64">float64</a>) (fovYRadHalf <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets this 4x4 matrix to the specified perspective-projection matrix.
fovYRad: vertical field-of-view angle in radians. a: aspect ratio. n: near-plane. f: far-plane.
</p>

				
				
			
				
				<h3 id="Mat4.RotationX">func (*Mat4) <a href="/target/mat4.go?s=4685:4723#L124">RotationX</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) RotationX(rad <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets this 4x4 matrix to a rotation matrix representing &#34;rotate rad radians around the X asis&#34;.
</p>

				
				
			
				
				<h3 id="Mat4.RotationY">func (*Mat4) <a href="/target/mat4.go?s=5048:5086#L133">RotationY</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) RotationY(rad <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets this 4x4 matrix to a rotation matrix representing &#34;rotate rad radians around the Y asis&#34;.
</p>

				
				
			
				
				<h3 id="Mat4.RotationZ">func (*Mat4) <a href="/target/mat4.go?s=5411:5449#L142">RotationZ</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) RotationZ(rad <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets this 4x4 matrix to a rotation matrix representing &#34;rotate rad radians around the Z asis&#34;.
</p>

				
				
			
				
				<h3 id="Mat4.Scaling">func (*Mat4) <a href="/target/mat4.go?s=5755:5789#L151">Scaling</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Scaling(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 4x4 matrix to a transformation matrix representing &#34;scale by vec&#34;
</p>

				
				
			
				
				<h3 id="Mat4.SetFromMult4">func (*Mat4) <a href="/target/mat4.go?s=6044:6088#L159">SetFromMult4</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) SetFromMult4(one, two *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Sets this 4x4 matrix to the result of multiplying one with two.
</p>

				
				
			
				
				<h3 id="Mat4.SetFromMultN">func (*Mat4) <a href="/target/mat4.go?s=7398:7441#L167">SetFromMultN</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) SetFromMultN(mats ...*<a href="#Mat4">Mat4</a>)</pre>
				<p>
Sets this 4x4 matrix to the result of multiplying all the specified mats with one another.
</p>

				
				
			
				
				<h3 id="Mat4.SetFromTransposeOf">func (*Mat4) <a href="/target/mat4.go?s=8722:8767#L186">SetFromTransposeOf</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) SetFromTransposeOf(mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Sets me to the transpose of mat.
</p>

				
				
			
				
				<h3 id="Mat4.Sub">func (*Mat4) <a href="/target/mat4.go?s=9199:9229#L201">Sub</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Sub(mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Subtracts mat from this 4x4 matrix.
</p>

				
				
			
				
				<h3 id="Mat4.ToInverseMat3">func (*Mat4) <a href="/target/mat4.go?s=9742:9782#L210">ToInverseMat3</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) ToInverseMat3(mat *<a href="#Mat3">Mat3</a>)</pre>
				<p>
Sets the specified 3x3 matrix to the inverse of me.
This method is currently in &#34;not needed right now and not sure if actually correct&#34; limbo.
</p>

				
				
			
				
				<h3 id="Mat4.Translation">func (*Mat4) <a href="/target/mat4.go?s=10367:10405#L226">Translation</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Translation(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 4x4 matrix to a transformation matrix representing &#34;translate by vec&#34;
</p>

				
				
			
				
				<h3 id="Mat4.Transposed">func (*Mat4) <a href="/target/mat4.go?s=9061:9101#L194">Transposed</a></h3>
				<pre>func (me *<a href="#Mat4">Mat4</a>) Transposed() (mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Returns the transpose of me.
</p>

				
				
			
		
			
			
			<h2 id="Vec2">type <a href="/target/vec2.go?s=61:93#L1">Vec2</a></h2>
			<pre>type Vec2 struct{ X, Y <a href="/pkg/builtin/#float64">float64</a> }</pre>
			<p>
A 2-dimensional vector.
</p>


			

			

			

			

			
				
				<h3 id="Vec2.Div">func (*Vec2) <a href="/target/vec2.go?s=176:212#L1">Div</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) Div(vec *<a href="#Vec2">Vec2</a>) *<a href="#Vec2">Vec2</a></pre>
				<p>
Returns a new 2D vector that is the result of dividing this 2D vector by vec.
</p>

				
				
			
				
				<h3 id="Vec2.Dot">func (*Vec2) <a href="/target/vec2.go?s=314:352#L6">Dot</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) Dot(vec *<a href="#Vec2">Vec2</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the dot product of this 2D vector and vec.
</p>

				
				
			
				
				<h3 id="Vec2.Length">func (*Vec2) <a href="/target/vec2.go?s=439:471#L11">Length</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) Length() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the length of this 2D vector.
</p>

				
				
			
				
				<h3 id="Vec2.Magnitude">func (*Vec2) <a href="/target/vec2.go?s=559:594#L16">Magnitude</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) Magnitude() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the magnitude of this 2D vector.
</p>

				
				
			
				
				<h3 id="Vec2.Mult">func (*Vec2) <a href="/target/vec2.go?s=717:754#L21">Mult</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) Mult(vec *<a href="#Vec2">Vec2</a>) *<a href="#Vec2">Vec2</a></pre>
				<p>
Returns a new 2D vector that is the result of multiplying this 2D vector with vec.
</p>

				
				
			
				
				<h3 id="Vec2.Normalize">func (*Vec2) <a href="/target/vec2.go?s=832:859#L26">Normalize</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) Normalize()</pre>
				<p>
Normalizes this 2D vector.
</p>

				
				
			
				
				<h3 id="Vec2.Normalized">func (*Vec2) <a href="/target/vec2.go?s=1039:1073#L33">Normalized</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) Normalized() *<a href="#Vec2">Vec2</a></pre>
				<p>
Returns a new 2D vector that is the normalized representation of this 2D vector.
</p>

				
				
			
				
				<h3 id="Vec2.NormalizedScaled">func (*Vec2) <a href="/target/vec2.go?s=1282:1342#L40">NormalizedScaled</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) NormalizedScaled(factor <a href="/pkg/builtin/#float64">float64</a>) (vec *<a href="#Vec2">Vec2</a>)</pre>
				<p>
Returns a new 2D vector that is the normalized representation of this 2D vector scaled by factor.
</p>

				
				
			
				
				<h3 id="Vec2.Scale">func (*Vec2) <a href="/target/vec2.go?s=1528:1565#L49">Scale</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) Scale(factor <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Multiplies all components in me with factor.
</p>

				
				
			
				
				<h3 id="Vec2.Scaled">func (*Vec2) <a href="/target/vec2.go?s=1686:1730#L54">Scaled</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) Scaled(factor <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Vec2">Vec2</a></pre>
				<p>
Returns a new 2D vector that represents this 2D vector scaled by factor.
</p>

				
				
			
				
				<h3 id="Vec2.String">func (*Vec2) <a href="/target/vec2.go?s=1780:1811#L58">String</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="Vec2.Sub">func (*Vec2) <a href="/target/vec2.go?s=1942:1978#L63">Sub</a></h3>
				<pre>func (me *<a href="#Vec2">Vec2</a>) Sub(vec *<a href="#Vec2">Vec2</a>) *<a href="#Vec2">Vec2</a></pre>
				<p>
Returns a new 2D vector that represents this 2D vector with vec subtracted.
</p>

				
				
			
		
			
			
			<h2 id="Vec3">type <a href="/target/vec3.go?s=73:110#L1">Vec3</a></h2>
			<pre>type Vec3 struct {
    X, Y, Z <a href="/pkg/builtin/#float64">float64</a>
}</pre>
			<p>
Represented a 3-dimensional vector.
</p>


			

			

			

			

			
				
				<h3 id="Vec3.AbsMax">func (*Vec3) <a href="/target/vec3.go?s=190:222#L3">AbsMax</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) AbsMax() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the maximum of the absolute values of all vector components in me.
</p>

				
				
			
				
				<h3 id="Vec3.Add">func (*Vec3) <a href="/target/vec3.go?s=334:364#L8">Add</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Add(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Adds vec to this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Add1">func (*Vec3) <a href="/target/vec3.go?s=608:641#L18">Add1</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Add1(val <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Adds val to all components of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Add3">func (*Vec3) <a href="/target/vec3.go?s=748:785#L23">Add3</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Add3(x, y, z <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Adds the specified components to this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.AddTo">func (*Vec3) <a href="/target/vec3.go?s=459:497#L13">AddTo</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) AddTo(vec *<a href="#Vec3">Vec3</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns the sum of me and vec.
</p>

				
				
			
				
				<h3 id="Vec3.AllEqual">func (*Vec3) <a href="/target/vec3.go?s=897:939#L28">AllEqual</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) AllEqual(val <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if all components of this 3D vector equal val.
</p>

				
				
			
				
				<h3 id="Vec3.AllGreaterOrEqual">func (*Vec3) <a href="/target/vec3.go?s=1068:1117#L33">AllGreaterOrEqual</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) AllGreaterOrEqual(vec *<a href="#Vec3">Vec3</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if this 3D vector is greater than or equal to vec.
</p>

				
				
			
				
				<h3 id="Vec3.AllInRange">func (*Vec3) <a href="/target/vec3.go?s=1271:1320#L38">AllInRange</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) AllInRange(min, max <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if this 3D vector is greater than or equal to min, and less than max.
</p>

				
				
			
				
				<h3 id="Vec3.AllInside">func (*Vec3) <a href="/target/vec3.go?s=1503:1549#L43">AllInside</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) AllInside(min, max *<a href="#Vec3">Vec3</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if this 3D vector is greater than min and less than max.
</p>

				
				
			
				
				<h3 id="Vec3.AllLessOrEqual">func (*Vec3) <a href="/target/vec3.go?s=1732:1778#L48">AllLessOrEqual</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) AllLessOrEqual(vec *<a href="#Vec3">Vec3</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if this 3D vector is less than or equal to vec.
</p>

				
				
			
				
				<h3 id="Vec3.Clamp">func (*Vec3) <a href="/target/vec3.go?s=4807:4844#L149">Clamp</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Clamp(min, max *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Clamps all components in me between min and max.
</p>

				
				
			
				
				<h3 id="Vec3.Clear">func (*Vec3) <a href="/target/vec3.go?s=1878:1901#L53">Clear</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Clear()</pre>
				<p>
Zeroes all components in me.
</p>

				
				
			
				
				<h3 id="Vec3.Cross">func (*Vec3) <a href="/target/vec3.go?s=2023:2061#L58">Cross</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Cross(vec *<a href="#Vec3">Vec3</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents the cross-product of this 3D vector and vec.
</p>

				
				
			
				
				<h3 id="Vec3.CrossNormalized">func (*Vec3) <a href="/target/vec3.go?s=2280:2332#L63">CrossNormalized</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) CrossNormalized(vec *<a href="#Vec3">Vec3</a>) (r *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Returns a new 3D vector that represents the cross-product of this 3D vector and vec, normalized.
</p>

				
				
			
				
				<h3 id="Vec3.DistanceFrom">func (*Vec3) <a href="/target/vec3.go?s=2551:2598#L71">DistanceFrom</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) DistanceFrom(vec *<a href="#Vec3">Vec3</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the distance of me from vec.
</p>

				
				
			
				
				<h3 id="Vec3.DistanceFromZero">func (*Vec3) <a href="/target/vec3.go?s=2694:2736#L76">DistanceFromZero</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) DistanceFromZero() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the distance of me from the &#39;center&#39; (zero).
</p>

				
				
			
				
				<h3 id="Vec3.Div">func (*Vec3) <a href="/target/vec3.go?s=2846:2882#L81">Div</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Div(vec *<a href="#Vec3">Vec3</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents this 3D vector divided by vec.
</p>

				
				
			
				
				<h3 id="Vec3.Div1">func (*Vec3) <a href="/target/vec3.go?s=3035:3074#L86">Div1</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Div1(val <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents this 3D vector&#39;s components all divided by val.
</p>

				
				
			
				
				<h3 id="Vec3.Dot">func (*Vec3) <a href="/target/vec3.go?s=3184:3222#L91">Dot</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Dot(vec *<a href="#Vec3">Vec3</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the dot product of this 3D vector and vec.
</p>

				
				
			
				
				<h3 id="Vec3.DotSub">func (*Vec3) <a href="/target/vec3.go?s=3353:3401#L96">DotSub</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) DotSub(vec1, vec2 *<a href="#Vec3">Vec3</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the dot product of this 3D vector and (vec1 minus vec2).
</p>

				
				
			
				
				<h3 id="Vec3.Equals">func (*Vec3) <a href="/target/vec3.go?s=3546:3584#L101">Equals</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Equals(vec *<a href="#Vec3">Vec3</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if this 3D vector equals vec.
</p>

				
				
			
				
				<h3 id="Vec3.Inv">func (*Vec3) <a href="/target/vec3.go?s=3694:3721#L106">Inv</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Inv() *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns the inverse of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Length">func (*Vec3) <a href="/target/vec3.go?s=3812:3844#L111">Length</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Length() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the length of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Magnitude">func (*Vec3) <a href="/target/vec3.go?s=3948:3983#L116">Magnitude</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Magnitude() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the magnitude of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.MakeFinite">func (*Vec3) <a href="/target/vec3.go?s=4126:4163#L121">MakeFinite</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) MakeFinite(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets each component of this 3D vector to the corresponding component in vec if the former is infinity.
</p>

				
				
			
				
				<h3 id="Vec3.ManhattanDistanceFrom">func (*Vec3) <a href="/target/vec3.go?s=4353:4409#L134">ManhattanDistanceFrom</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) ManhattanDistanceFrom(vec *<a href="#Vec3">Vec3</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the &#34;manhattan distance&#34; of me from vec.
</p>

				
				
			
				
				<h3 id="Vec3.Max">func (*Vec3) <a href="/target/vec3.go?s=4542:4571#L139">Max</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Max() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the biggest component of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Min">func (*Vec3) <a href="/target/vec3.go?s=4675:4704#L144">Min</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Min() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the smallest component of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Mult">func (*Vec3) <a href="/target/vec3.go?s=5151:5188#L171">Mult</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Mult(vec *<a href="#Vec3">Vec3</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents this 3D vector multiplied with vec.
</p>

				
				
			
				
				<h3 id="Vec3.Negate">func (*Vec3) <a href="/target/vec3.go?s=5501:5525#L181">Negate</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Negate()</pre>
				<p>
Reverses the sign of each of this 3D vector&#39;s components.
</p>

				
				
			
				
				<h3 id="Vec3.Negated">func (*Vec3) <a href="/target/vec3.go?s=5684:5715#L186">Negated</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Negated() *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a vector with each component representing the negative (sign inverted) corresponding component in me.
</p>

				
				
			
				
				<h3 id="Vec3.Normalize">func (*Vec3) <a href="/target/vec3.go?s=5786:5813#L191">Normalize</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Normalize()</pre>
				<p>
Normalizes this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Normalized">func (*Vec3) <a href="/target/vec3.go?s=5999:6039#L200">Normalized</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Normalized() (vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Returns a new 3D vector that represents this 3D vector, normalized.
</p>

				
				
			
				
				<h3 id="Vec3.NormalizedScaled">func (*Vec3) <a href="/target/vec3.go?s=6278:6338#L210">NormalizedScaled</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) NormalizedScaled(factor <a href="/pkg/builtin/#float64">float64</a>) (vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Returns a new 3D vector that represents this 3D vector, normalized, then scaled by factor.
</p>

				
				
			
				
				<h3 id="Vec3.RotateDeg">func (*Vec3) <a href="/target/vec3.go?s=6464:6519#L217">RotateDeg</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) RotateDeg(angleDeg <a href="/pkg/builtin/#float64">float64</a>, axis *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Rotates this 3D vector angleDeg degrees around the specified axis.
</p>

				
				
			
				
				<h3 id="Vec3.RotateRad">func (*Vec3) <a href="/target/vec3.go?s=6637:6692#L222">RotateRad</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) RotateRad(angleRad <a href="/pkg/builtin/#float64">float64</a>, axis *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Rotates this 3D vector angleRad radians around the specified axis.
</p>

				
				
			
				
				<h3 id="Vec3.Scale">func (*Vec3) <a href="/target/vec3.go?s=7034:7071#L233">Scale</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Scale(factor <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Scales this 3D vector by factor.
</p>

				
				
			
				
				<h3 id="Vec3.ScaleAdd">func (*Vec3) <a href="/target/vec3.go?s=7186:7229#L238">ScaleAdd</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) ScaleAdd(factor, add *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Scales this 3D vector by factor, then adds add.
</p>

				
				
			
				
				<h3 id="Vec3.Scaled">func (*Vec3) <a href="/target/vec3.go?s=7399:7443#L243">Scaled</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Scaled(factor <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents this 3D vector scaled by factor.
</p>

				
				
			
				
				<h3 id="Vec3.ScaledAdded">func (*Vec3) <a href="/target/vec3.go?s=7600:7660#L248">ScaledAdded</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) ScaledAdded(factor <a href="/pkg/builtin/#float64">float64</a>, add *<a href="#Vec3">Vec3</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents this 3D vector scaled by factor, then add added.
</p>

				
				
			
				
				<h3 id="Vec3.Set">func (*Vec3) <a href="/target/vec3.go?s=7820:7856#L253">Set</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Set(x, y, z <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets the components of this 3D vector to the specified value.
</p>

				
				
			
				
				<h3 id="Vec3.SetFrom">func (*Vec3) <a href="/target/vec3.go?s=7976:8010#L258">SetFrom</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFrom(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets the components of this 3D vector to the same values as the components of vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromAdd">func (*Vec3) <a href="/target/vec3.go?s=8118:8162#L263">SetFromAdd</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromAdd(vec1, vec2 *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 3D vector to the result of adding vec1 and vec2.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromAddAdd">func (*Vec3) <a href="/target/vec3.go?s=8317:8361#L268">SetFromAddAdd</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromAddAdd(a, b, c *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets each vector component in me to the sum of the corresponding a+b+c component.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromAddMult">func (*Vec3) <a href="/target/vec3.go?s=8510:8563#L273">SetFromAddMult</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromAddMult(add, mul1, mul2 *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 3D vector to the result of multiplying mul1 with mul2, then adding add.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromAddScaled">func (*Vec3) <a href="/target/vec3.go?s=8736:8799#L278">SetFromAddScaled</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromAddScaled(vec1, vec2 *<a href="#Vec3">Vec3</a>, mul <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets this 3D vector to the result of scaling vec2 by mul, then adding vec1.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromAddSub">func (*Vec3) <a href="/target/vec3.go?s=8969:9013#L283">SetFromAddSub</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromAddSub(a, b, c *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets each vector component in me to the result of the corresponding a+b-c component.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromCos">func (*Vec3) <a href="/target/vec3.go?s=9171:9208#L288">SetFromCos</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromCos(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets each component of this 3D vector to the cosine of the corresponding component in vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromCross">func (*Vec3) <a href="/target/vec3.go?s=9368:9407#L293">SetFromCross</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromCross(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Modifies this Vec3 to represent the cross-product of its previous value and vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromCrossOf">func (*Vec3) <a href="/target/vec3.go?s=9561:9607#L298">SetFromCrossOf</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromCrossOf(one, two *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets me to the cross product of one and two.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromDegToRad">func (*Vec3) <a href="/target/vec3.go?s=9851:9893#L303">SetFromDegToRad</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromDegToRad(deg *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets each component of this 3D vector to the radian equivalent of the degree angle stored in the corresponding component in vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromEpsilon32">func (*Vec3) <a href="/target/vec3.go?s=10073:10107#L308">SetFromEpsilon32</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromEpsilon32()</pre>
				<p>
Sets each component of this 3D vector to Epsilon32 if it is 0 or greater but smaller than Epsilon32.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromEpsilon64">func (*Vec3) <a href="/target/vec3.go?s=10403:10437#L321">SetFromEpsilon64</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromEpsilon64()</pre>
				<p>
Sets each component of this 3D vector to Epsilon64 if it is 0 or greater but smaller than Epsilon64.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromInv">func (*Vec3) <a href="/target/vec3.go?s=10675:10712#L334">SetFromInv</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromInv(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 3D vector to the inverse of vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromMult">func (*Vec3) <a href="/target/vec3.go?s=10827:10868#L339">SetFromMult</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromMult(v1, v2 *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 3D vector to the result of v1 multiplied with v2.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromNormalized">func (*Vec3) <a href="/target/vec3.go?s=11525:11569#L359">SetFromNormalized</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromNormalized(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets me to the result  of normalizing vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromRotation">func (*Vec3) <a href="/target/vec3.go?s=11730:11788#L366">SetFromRotation</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromRotation(pos, rotCos, rotSin *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 3D vector to pos rotated as expressed in rotCos and rotSin.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromScaled">func (*Vec3) <a href="/target/vec3.go?s=10985:11038#L344">SetFromScaled</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromScaled(vec *<a href="#Vec3">Vec3</a>, mul <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets this 3D vector to the result of vec scaled by mul.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromScaledSub">func (*Vec3) <a href="/target/vec3.go?s=11170:11233#L349">SetFromScaledSub</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromScaledSub(vec1, vec2 *<a href="#Vec3">Vec3</a>, mul <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets this 3D vector to the result of (vec1 minus vec2), scaled by mul.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSin">func (*Vec3) <a href="/target/vec3.go?s=12037:12074#L374">SetFromSin</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromSin(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 3D vector to the sine of vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromStep">func (*Vec3) <a href="/target/vec3.go?s=12296:12356#L379">SetFromStep</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromStep(edge <a href="/pkg/builtin/#float64">float64</a>, vec, v0, v1 *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets each component of this 3D vector to the corresponding component in v0 if it is less than edge, else to the corresponding component in v1.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSub">func (*Vec3) <a href="/target/vec3.go?s=12599:12643#L398">SetFromSub</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromSub(vec1, vec2 *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 3D vector to the result of vec1 minus vec2.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSubAdd">func (*Vec3) <a href="/target/vec3.go?s=12801:12845#L403">SetFromSubAdd</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromSubAdd(a, b, c *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets each vector component in me to the result of the corresponding a-b+c component.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSubMult">func (*Vec3) <a href="/target/vec3.go?s=13420:13473#L418">SetFromSubMult</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromSubMult(sub1, sub2, mul *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 3D vector to the result of (sub1 minus sub2), scaled by mul.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSubScaled">func (*Vec3) <a href="/target/vec3.go?s=13005:13068#L408">SetFromSubScaled</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromSubScaled(v1, v2 *<a href="#Vec3">Vec3</a>, v2Scale <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets each vector component in me to the result of the corresponding v1-v2*v2Scale component.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSubSub">func (*Vec3) <a href="/target/vec3.go?s=13238:13282#L413">SetFromSubSub</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromSubSub(a, b, c *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets each vector component in me to the result of the corresponding a-b-c component.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSwapSign">func (*Vec3) <a href="/target/vec3.go?s=11388:11430#L354">SetFromSwapSign</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetFromSwapSign(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets this 3D vector to vec with each component&#39;s sign reversed.
</p>

				
				
			
				
				<h3 id="Vec3.SetToMax">func (*Vec3) <a href="/target/vec3.go?s=13616:13642#L423">SetToMax</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetToMax()</pre>
				<p>
Sets all components in me to math.MaxFloat64.
</p>

				
				
			
				
				<h3 id="Vec3.SetToMin">func (*Vec3) <a href="/target/vec3.go?s=13768:13794#L428">SetToMin</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SetToMin()</pre>
				<p>
Sets all components in me to -math.MaxFloat64.
</p>

				
				
			
				
				<h3 id="Vec3.Sign">func (*Vec3) <a href="/target/vec3.go?s=13981:14009#L433">Sign</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Sign() *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a 3D vector where each component indicates the sign of this 3D vector&#39;s corresponding component.
</p>

				
				
			
				
				<h3 id="Vec3.String">func (*Vec3) <a href="/target/vec3.go?s=14119:14150#L438">String</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
Returns a string representation of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Sub">func (*Vec3) <a href="/target/vec3.go?s=14287:14323#L443">Sub</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Sub(vec *<a href="#Vec3">Vec3</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents (this 3D vector minus vec).
</p>

				
				
			
				
				<h3 id="Vec3.SubDivMult">func (*Vec3) <a href="/target/vec3.go?s=14492:14545#L448">SubDivMult</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SubDivMult(sub, div, mul *<a href="#Vec3">Vec3</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents (this 3D vector minus sub) divided by div, multiplied with mul.
</p>

				
				
			
				
				<h3 id="Vec3.SubDot">func (*Vec3) <a href="/target/vec3.go?s=14724:14765#L453">SubDot</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SubDot(vec *<a href="#Vec3">Vec3</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the dot product of (this 3D vector minus vec)
</p>

				
				
			
				
				<h3 id="Vec3.SubFloorDivMult">func (*Vec3) <a href="/target/vec3.go?s=15008:15068#L458">SubFloorDivMult</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SubFloorDivMult(floorDiv, mul <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents the result of (this 3D vector divided by floorDiv) floored, then scaled by mul.
</p>

				
				
			
				
				<h3 id="Vec3.SubFrom">func (*Vec3) <a href="/target/vec3.go?s=15266:15308#L463">SubFrom</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SubFrom(val <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents (val minus this 3D vector).
</p>

				
				
			
				
				<h3 id="Vec3.SubScaled">func (*Vec3) <a href="/target/vec3.go?s=15450:15505#L468">SubScaled</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SubScaled(vec *<a href="#Vec3">Vec3</a>, val <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a new 3D vector that represents (this 3D vector minus vec), scaled by val.
</p>

				
				
			
				
				<h3 id="Vec3.SubVec">func (*Vec3) <a href="/target/vec3.go?s=15629:15662#L473">SubVec</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) SubVec(vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Subtracts vec from this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Times">func (*Vec3) <a href="/target/vec3.go?s=5346:5390#L176">Times</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) Times(x, y, z <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Vec3">Vec3</a></pre>
				<p>
Returns a vector with each component in me multiplied by the corresponding specified factor.
</p>

				
				
			
				
				<h3 id="Vec3.TransformCoord">func (*Vec3) <a href="/target/vec3.go?s=15809:15850#L478">TransformCoord</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) TransformCoord(mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Transform this coordinate vector according to the specified transformation matrix.
</p>

				
				
			
				
				<h3 id="Vec3.TransformNormal">func (*Vec3) <a href="/target/vec3.go?s=16036:16091#L486">TransformNormal</a></h3>
				<pre>func (me *<a href="#Vec3">Vec3</a>) TransformNormal(mat *<a href="#Mat4">Mat4</a>, absMat <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Transform this normal vector according to the specified transformation matrix.
</p>

				
				
			
		
			
			
			<h2 id="Vec4">type <a href="/target/vec4.go?s=99:178#L1">Vec4</a></h2>
			<pre>type Vec4 struct {
    <span class="comment">//	X, Y, Z</span>
    <a href="#Vec3">Vec3</a>

    <span class="comment">//	The 4th vector component</span>
    W <a href="/pkg/builtin/#float64">float64</a>
}</pre>
			<p>
Represents an arbitrary 4-dimensional vector or a Quaternion.
</p>


			

			

			

			

			
				
				<h3 id="Vec4.Clone">func (*Vec4) <a href="/target/vec4.go?s=205:238#L7">Clone</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) Clone() (q *<a href="#Vec4">Vec4</a>)</pre>
				<p>
Returns a copy of me.
</p>

				
				
			
				
				<h3 id="Vec4.Conjugate">func (*Vec4) <a href="/target/vec4.go?s=314:341#L13">Conjugate</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) Conjugate()</pre>
				<p>
Negates the X, Y, Z components in me, but not W.
</p>

				
				
			
				
				<h3 id="Vec4.Conjugated">func (*Vec4) <a href="/target/vec4.go?s=446:484#L18">Conjugated</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) Conjugated() (v *<a href="#Vec4">Vec4</a>)</pre>
				<p>
Returns a Vec4 that is the conjugated equivalent of me.
</p>

				
				
			
				
				<h3 id="Vec4.Length">func (*Vec4) <a href="/target/vec4.go?s=590:622#L25">Length</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) Length() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the length of me.
</p>

				
				
			
				
				<h3 id="Vec4.Magnitude">func (*Vec4) <a href="/target/vec4.go?s=730:765#L30">Magnitude</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) Magnitude() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the magnitude of me.
</p>

				
				
			
				
				<h3 id="Vec4.MultMat4Vec3">func (*Vec4) <a href="/target/vec4.go?s=2253:2303#L79">MultMat4Vec3</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) MultMat4Vec3(mat *<a href="#Mat4">Mat4</a>, vec *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Sets me to the result of multiplying matrix mat with 3D-vector vec.
</p>

				
				
			
				
				<h3 id="Vec4.MultMat4Vec4">func (*Vec4) <a href="/target/vec4.go?s=2698:2748#L87">MultMat4Vec4</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) MultMat4Vec4(mat *<a href="#Mat4">Mat4</a>, vec *<a href="#Vec4">Vec4</a>)</pre>
				<p>
Sets me to the result of multiplying matrix mat with 4D-vector vec.
</p>

				
				
			
				
				<h3 id="Vec4.Normalize">func (*Vec4) <a href="/target/vec4.go?s=855:882#L35">Normalize</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) Normalize()</pre>
				<p>
Normalizes this Vec4 according to me.Magnitude().
</p>

				
				
			
				
				<h3 id="Vec4.NormalizeFrom">func (*Vec4) <a href="/target/vec4.go?s=1114:1162#L45">NormalizeFrom</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) NormalizeFrom(magnitude <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Normalizes me according to the specified magnitude.
</p>

				
				
			
				
				<h3 id="Vec4.Normalized">func (*Vec4) <a href="/target/vec4.go?s=1322:1356#L51">Normalized</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) Normalized() *<a href="#Vec4">Vec4</a></pre>
				<p>
Returns the normalized Vec4 of me.
</p>

				
				
			
				
				<h3 id="Vec4.Scale">func (*Vec4) <a href="/target/vec4.go?s=2087:2119#L74">Scale</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) Scale(v <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Scales all components in me by factor v.
</p>

				
				
			
				
				<h3 id="Vec4.SetFromConjugated">func (*Vec4) <a href="/target/vec4.go?s=1550:1592#L61">SetFromConjugated</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) SetFromConjugated(c *<a href="#Vec4">Vec4</a>)</pre>
				<p>
Sets me to the conjugated equivalent of c.
</p>

				
				
			
				
				<h3 id="Vec4.SetFromMult">func (*Vec4) <a href="/target/vec4.go?s=1750:1789#L66">SetFromMult</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) SetFromMult(l, r *<a href="#Vec4">Vec4</a>)</pre>
				<p>
Applies vector component multiplications of l and r to me, as needed by the Vec3.RotateRad() method.
</p>

				
				
			
				
				<h3 id="Vec4.SetFromMult3">func (*Vec4) <a href="/target/vec4.go?s=3192:3238#L95">SetFromMult3</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) SetFromMult3(q *<a href="#Vec4">Vec4</a>, v *<a href="#Vec3">Vec3</a>)</pre>
				<p>
Applies vector component multiplications of q and v to me, as needed by the Vec3.RotateRad() method.
</p>

				
				
			
				
				<h3 id="Vec4.SetFromMultMat4">func (*Vec4) <a href="/target/vec4.go?s=3507:3549#L103">SetFromMultMat4</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) SetFromMultMat4(mat *<a href="#Mat4">Mat4</a>)</pre>
				<p>
Sets me to the result of multiplying matrix mat with 4D-vector me.
</p>

				
				
			
				
				<h3 id="Vec4.String">func (*Vec4) <a href="/target/vec4.go?s=3643:3674#L108">String</a></h3>
				<pre>func (me *<a href="#Vec4">Vec4</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>
Returns a string representation of this 3D vector.
</p>

				
				
			
		
	

	








		</div></div>
	</body>
</html>