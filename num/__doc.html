<html>
	<head>
		<title>Package github.com/metaleap/go-util/num</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/metaleap/go-util/num</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/metaleap/go-util/num"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
A few maths-helpers, plus vectors, matrices and quaternions.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#AllEqual">func AllEqual(test float64, vals ...float64) bool</a></dd>
			
				
				<dd><a href="#Clamp">func Clamp(val, c0, c1 float64) float64</a></dd>
			
				
				<dd><a href="#DegToRad">func DegToRad(deg float64) float64</a></dd>
			
				
				<dd><a href="#Din1">func Din1(val, max float64) float64</a></dd>
			
				
				<dd><a href="#Fin1">func Fin1(val, max float32) float32</a></dd>
			
				
				<dd><a href="#IsEven">func IsEven(val int) bool</a></dd>
			
				
				<dd><a href="#IsInt">func IsInt(val float64) bool</a></dd>
			
				
				<dd><a href="#IsMod0">func IsMod0(v, m int) bool</a></dd>
			
				
				<dd><a href="#Mat3Identities">func Mat3Identities(mats ...*Mat3)</a></dd>
			
				
				<dd><a href="#Mat4Identities">func Mat4Identities(mats ...*Mat4)</a></dd>
			
				
				<dd><a href="#Mini">func Mini(v1, v2 int) int</a></dd>
			
				
				<dd><a href="#Mix">func Mix(x, y, a float64) float64</a></dd>
			
				
				<dd><a href="#RadToDeg">func RadToDeg(rad float64) float64</a></dd>
			
				
				<dd><a href="#Round">func Round(v float64) (fint float64)</a></dd>
			
				
				<dd><a href="#Saturate">func Saturate(v float64) float64</a></dd>
			
				
				<dd><a href="#Sign">func Sign(v float64) (sign float64)</a></dd>
			
				
				<dd><a href="#Step">func Step(edge, x float64) (step int)</a></dd>
			
			
				
				<dd><a href="#Bag">type Bag</a></dd>
				
				
			
				
				<dd><a href="#Mat3">type Mat3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat3Identity">func NewMat3Identity() (mat *Mat3)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat3.Identity">func (me *Mat3) Identity()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat3.Transpose">func (me *Mat3) Transpose()</a></dd>
				
			
				
				<dd><a href="#Mat4">type Mat4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Add">func NewMat4Add(a, b *Mat4) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Frustum">func NewMat4Frustum(left, right, bottom, top, near, far float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Identity">func NewMat4Identity() (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4LookAt">func NewMat4LookAt(bag *Bag, lookTarget, worldUp *Vec3) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Mult1">func NewMat4Mult1(m *Mat4, v float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Mult4">func NewMat4Mult4(one, two *Mat4) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4MultN">func NewMat4MultN(bag *Bag, mats ...*Mat4) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Perspective">func NewMat4Perspective(bag *Bag, fovY, aspect, near, far float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4RotationX">func NewMat4RotationX(bag *Bag, rad float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4RotationY">func NewMat4RotationY(bag *Bag, rad float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4RotationZ">func NewMat4RotationZ(bag *Bag, rad float64) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Scaling">func NewMat4Scaling(vec *Vec3) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Sub">func NewMat4Sub(a, b *Mat4) (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMat4Translation">func NewMat4Translation(vec *Vec3) (mat *Mat4)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Add">func (me *Mat4) Add(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Clear">func (me *Mat4) Clear()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Clone">func (me *Mat4) Clone() (mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.CopyFrom">func (me *Mat4) CopyFrom(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.CopyTo">func (me *Mat4) CopyTo(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Frustum">func (me *Mat4) Frustum(left, right, bottom, top, near, far float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Identity">func (me *Mat4) Identity()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.LookAt">func (me *Mat4) LookAt(bag *Bag, lookTarget, worldUp *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Mult1">func (me *Mat4) Mult1(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Perspective">func (me *Mat4) Perspective(bag *Bag, fovY, aspect, near, far float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.RotationX">func (me *Mat4) RotationX(bag *Bag, rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.RotationY">func (me *Mat4) RotationY(bag *Bag, rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.RotationZ">func (me *Mat4) RotationZ(bag *Bag, rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Scaling">func (me *Mat4) Scaling(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.SetFromMult4">func (me *Mat4) SetFromMult4(one, two *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.SetFromMultN">func (me *Mat4) SetFromMultN(bag *Bag, mats ...*Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Sub">func (me *Mat4) Sub(mat *Mat4)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.ToInverseMat3">func (me *Mat4) ToInverseMat3(mat *Mat3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mat4.Translation">func (me *Mat4) Translation(vec *Vec3)</a></dd>
				
			
				
				<dd><a href="#Quat">type Quat</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.Clone">func (me *Quat) Clone() (q *Quat)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.Conjugate">func (me *Quat) Conjugate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.Conjugated">func (me *Quat) Conjugated() *Quat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.Length">func (me *Quat) Length() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.Magnitude">func (me *Quat) Magnitude() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.MultMat4Vec3">func (me *Quat) MultMat4Vec3(mat *Mat4, vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.MultMat4Vec4">func (me *Quat) MultMat4Vec4(mat *Mat4, vec *Quat)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.Normalize">func (me *Quat) Normalize(bag *Bag)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.Normalized">func (me *Quat) Normalized(bag *Bag) (q *Quat)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.Scale">func (me *Quat) Scale(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.SetFromConjugated">func (me *Quat) SetFromConjugated(c *Quat)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.SetFromMult">func (me *Quat) SetFromMult(l, r *Quat)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.SetFromMult3">func (me *Quat) SetFromMult3(q *Quat, v *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Quat.SetFromMultMat4">func (me *Quat) SetFromMultMat4(mat *Mat4)</a></dd>
				
			
				
				<dd><a href="#Vec2">type Vec2</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Div">func (me *Vec2) Div(vec *Vec2) *Vec2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Dot">func (me *Vec2) Dot(vec *Vec2) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Length">func (me *Vec2) Length() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Magnitude">func (me *Vec2) Magnitude() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Mult">func (me *Vec2) Mult(vec *Vec2) *Vec2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Normalize">func (me *Vec2) Normalize()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Normalized">func (me *Vec2) Normalized() *Vec2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.NormalizedScaled">func (me *Vec2) NormalizedScaled(factor float64) (vec *Vec2)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Scale">func (me *Vec2) Scale(factor float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Scaled">func (me *Vec2) Scaled(factor float64) *Vec2</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec2.Sub">func (me *Vec2) Sub(vec *Vec2) *Vec2</a></dd>
				
			
				
				<dd><a href="#Vec3">type Vec3</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Add">func (me *Vec3) Add(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Add1">func (me *Vec3) Add1(val float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Add3">func (me *Vec3) Add3(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AllEqual">func (me *Vec3) AllEqual(val float64) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AllGreaterOrEqual">func (me *Vec3) AllGreaterOrEqual(vec *Vec3) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AllInRange">func (me *Vec3) AllInRange(min, max float64) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AllInside">func (me *Vec3) AllInside(min, max *Vec3) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.AllLessOrEqual">func (me *Vec3) AllLessOrEqual(vec *Vec3) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Cross">func (me *Vec3) Cross(vec *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.CrossNormalized">func (me *Vec3) CrossNormalized(vec *Vec3) (r *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Div">func (me *Vec3) Div(vec *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Div1">func (me *Vec3) Div1(val float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Dot">func (me *Vec3) Dot(vec *Vec3) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.DotSub">func (me *Vec3) DotSub(vec1, vec2 *Vec3) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Equals">func (me *Vec3) Equals(vec *Vec3) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Inv">func (me *Vec3) Inv() *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Length">func (me *Vec3) Length() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Magnitude">func (me *Vec3) Magnitude() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.MakeFinite">func (me *Vec3) MakeFinite(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Max">func (me *Vec3) Max() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Min">func (me *Vec3) Min() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Mult">func (me *Vec3) Mult(vec *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Mult1">func (me *Vec3) Mult1(val float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Normalize">func (me *Vec3) Normalize()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Normalized">func (me *Vec3) Normalized() (vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.NormalizedScaled">func (me *Vec3) NormalizedScaled(factor float64) (vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.RotateDeg">func (me *Vec3) RotateDeg(bag *Bag, angleDeg float64, axis *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.RotateRad">func (me *Vec3) RotateRad(bag *Bag, angleRad float64, axis *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Scale">func (me *Vec3) Scale(factor float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.ScaleAdd">func (me *Vec3) ScaleAdd(factor, add *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Scaled">func (me *Vec3) Scaled(factor float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.ScaledAdded">func (me *Vec3) ScaledAdded(factor float64, add *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Set">func (me *Vec3) Set(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFrom">func (me *Vec3) SetFrom(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromAdd">func (me *Vec3) SetFromAdd(vec1, vec2 *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromAddMult">func (me *Vec3) SetFromAddMult(add, mul1, mul2 *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromAddMult1">func (me *Vec3) SetFromAddMult1(vec1, vec2 *Vec3, mul float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromCos">func (me *Vec3) SetFromCos(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromCross">func (me *Vec3) SetFromCross(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromCrossOf">func (me *Vec3) SetFromCrossOf(one, two *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromDegToRad">func (me *Vec3) SetFromDegToRad(deg *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromEpsilon32">func (me *Vec3) SetFromEpsilon32()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromEpsilon64">func (me *Vec3) SetFromEpsilon64()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromInv">func (me *Vec3) SetFromInv(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromMult">func (me *Vec3) SetFromMult(v1, v2 *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromMult1">func (me *Vec3) SetFromMult1(vec *Vec3, mul float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromMult1Sub">func (me *Vec3) SetFromMult1Sub(vec1, vec2 *Vec3, mul float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromNeg">func (me *Vec3) SetFromNeg(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromNormalized">func (me *Vec3) SetFromNormalized(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromRotation">func (me *Vec3) SetFromRotation(pos, rotCos, rotSin *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSin">func (me *Vec3) SetFromSin(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromStep">func (me *Vec3) SetFromStep(edge float64, vec, v0, v1 *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSub">func (me *Vec3) SetFromSub(vec1, vec2 *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSubMult">func (me *Vec3) SetFromSubMult(sub1, sub2, mul *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SetFromSubMult1">func (me *Vec3) SetFromSubMult1(vec1, vec2 *Vec3, mul float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Sign">func (me *Vec3) Sign() *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.String">func (me *Vec3) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.Sub">func (me *Vec3) Sub(vec *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubDivMult">func (me *Vec3) SubDivMult(sub, div, mul *Vec3) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubDot">func (me *Vec3) SubDot(vec *Vec3) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubFloorDivMult">func (me *Vec3) SubFloorDivMult(floorDiv, mul float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubFrom">func (me *Vec3) SubFrom(val float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubMult">func (me *Vec3) SubMult(vec *Vec3, val float64) *Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SubVec">func (me *Vec3) SubVec(vec *Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Vec3.SwapSigns">func (me *Vec3) SwapSigns()</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/mat3.go">mat3.go</a>
			
				<a href="/target/mat4.go">mat4.go</a>
			
				<a href="/target/num.go">num.go</a>
			
				<a href="/target/vec2.go">vec2.go</a>
			
				<a href="/target/vec3.go">vec3.go</a>
			
				<a href="/target/vec4.go">vec4.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    PiDiv180  = math.Pi / 180
    PiHalfDiv = 0.5 / math.Pi
)</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    Epsilon32 = math.SmallestNonzeroFloat32
    Epsilon64 = math.SmallestNonzeroFloat64

    <span class="comment">//	Contains the positive-infinity float64 returned by math.Inf(1).</span>
    Infinity = math.Inf(1)

    <span class="comment">//	Contains the negative-infinity float64 returned by math.Inf(-1)</span>
    NegInfinity = math.Inf(-1)
)</pre>
				
			
		
		
			
			
			<h2 id="AllEqual">func <a href="/target/num.go?s=804:853#L34">AllEqual</a></h2>
			<pre>func AllEqual(test float64, vals ...float64) bool</pre>
			<p>
Returns true if all vals equal test.
</p>

			
		
			
			
			<h2 id="Clamp">func <a href="/target/num.go?s=984:1023#L44">Clamp</a></h2>
			<pre>func Clamp(val, c0, c1 float64) float64</pre>
			<p>
Clamps val between c0 and c1
</p>

			
		
			
			
			<h2 id="DegToRad">func <a href="/target/num.go?s=1190:1224#L56">DegToRad</a></h2>
			<pre>func DegToRad(deg float64) float64</pre>
			<p>
Converts the specified degrees to radians.
</p>

			
		
			
			
			<h2 id="Din1">func <a href="/target/num.go?s=1360:1395#L62">Din1</a></h2>
			<pre>func Din1(val, max float64) float64</pre>
			<p>
Returns the &#34;normalized ratio&#34; of val to max.
Example: for max = 900 and val = 300, returns 0.33333.
</p>

			
		
			
			
			<h2 id="Fin1">func <a href="/target/num.go?s=1532:1567#L68">Fin1</a></h2>
			<pre>func Fin1(val, max float32) float32</pre>
			<p>
Returns the &#34;normalized ratio&#34; of val to max.
Example: for max = 900 and val = 300, returns 0.33333.
</p>

			
		
			
			
			<h2 id="IsEven">func <a href="/target/num.go?s=2454:2479#L95">IsEven</a></h2>
			<pre>func IsEven(val int) bool</pre>
			<p>
Returns true if val is even
</p>

			
		
			
			
			<h2 id="IsInt">func <a href="/target/num.go?s=2571:2599#L100">IsInt</a></h2>
			<pre>func IsInt(val float64) bool</pre>
			<p>
Returns true if val represents an integer
</p>

			
		
			
			
			<h2 id="IsMod0">func <a href="/target/num.go?s=2688:2714#L106">IsMod0</a></h2>
			<pre>func IsMod0(v, m int) bool</pre>
			<p>
Returns true if math.Mod(v, m) is zero
</p>

			
		
			
			
			<h2 id="Mat3Identities">func <a href="/target/mat3.go?s=654:688#L24">Mat3Identities</a></h2>
			<pre>func Mat3Identities(mats ...*Mat3)</pre>
			<p>
Calls the Identity() method on all specified mats.
</p>

			
		
			
			
			<h2 id="Mat4Identities">func <a href="/target/mat4.go?s=11517:11551#L200">Mat4Identities</a></h2>
			<pre>func Mat4Identities(mats ...*Mat4)</pre>
			<p>
Calls the Identity() method on all specified mats.
</p>

			
		
			
			
			<h2 id="Mini">func <a href="/target/num.go?s=3146:3171#L133">Mini</a></h2>
			<pre>func Mini(v1, v2 int) int</pre>
			<p>
Returns the smaller of two values.
</p>

			
		
			
			
			<h2 id="Mix">func <a href="/target/num.go?s=3310:3343#L141">Mix</a></h2>
			<pre>func Mix(x, y, a float64) float64</pre>
			<p>
Returns x if a is 0, y if a is 1, or a corresponding mix of both if a is between 0 and 1.
</p>

			
		
			
			
			<h2 id="RadToDeg">func <a href="/target/num.go?s=3427:3461#L146">RadToDeg</a></h2>
			<pre>func RadToDeg(rad float64) float64</pre>
			<p>
Converts the specified radians to degrees.
</p>

			
		
			
			
			<h2 id="Round">func <a href="/target/num.go?s=3607:3643#L151">Round</a></h2>
			<pre>func Round(v float64) (fint float64)</pre>
			<p>
Returns (the equivalent of) math.Ceil(v) if fraction &gt;= 0.5, otherwise returns (the equivalent of) math.Floor(v).
</p>

			
		
			
			
			<h2 id="Saturate">func <a href="/target/num.go?s=3761:3793#L160">Saturate</a></h2>
			<pre>func Saturate(v float64) float64</pre>
			<p>
Clamps v between 0 and 1.
</p>

			
		
			
			
			<h2 id="Sign">func <a href="/target/num.go?s=3893:3928#L165">Sign</a></h2>
			<pre>func Sign(v float64) (sign float64)</pre>
			<p>
Returns -1 if v is negative, 1 if v is positive, or 0 if v is zero.
</p>

			
		
			
			
			<h2 id="Step">func <a href="/target/num.go?s=4073:4110#L176">Step</a></h2>
			<pre>func Step(edge, x float64) (step int)</pre>
			<p>
Returns 0 if x &lt; edge, otherwise returns 1.
</p>

			
		
		
			
			
			<h2 id="Bag">type <a href="/target/num.go?s=201:416#L1">Bag</a></h2>
			<pre>type Bag struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
You&#39;ll need to supply some Vec3, Quat and Mat4 methods with such a &#34;Bag&#34;.
It is recommended to keep a single Bag (per thread / goroutine!) for indefinite reuse.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Mat3">type <a href="/target/mat3.go?s=42:62#L1">Mat3</a></h2>
			<pre>type Mat3 [9]float64</pre>
			<p>
Represents a 3x3 matrix.
</p>


			

			

			

			
				
				<h3 id="NewMat3Identity">func <a href="/target/mat3.go?s=780:814#L31">NewMat3Identity</a></h3>
				<pre>func NewMat3Identity() (mat *Mat3)</pre>
				<p>
Returns a new 3x3 identity matrix.
</p>

				
			

			
				
				<h3 id="Mat3.Identity">func (*Mat3) <a href="/target/mat3.go?s=264:290#L7">Identity</a></h3>
				<pre>func (me *Mat3) Identity()</pre>
				<p>
Sets this 3x3 matrix to the 3x3 identity matrix.
</p>

				
				
			
				
				<h3 id="Mat3.Transpose">func (*Mat3) <a href="/target/mat3.go?s=339:366#L12">Transpose</a></h3>
				<pre>func (me *Mat3) Transpose()</pre>
				<p>
Transposes this 3x3 matrix.
</p>

				
				
			
		
			
			
			<h2 id="Mat4">type <a href="/target/mat4.go?s=75:96#L1">Mat4</a></h2>
			<pre>type Mat4 [16]float64</pre>
			<p>
Represents a 4x4 column-major matrix.
</p>


			

			

			

			
				
				<h3 id="NewMat4Add">func <a href="/target/mat4.go?s=11675:11714#L207">NewMat4Add</a></h3>
				<pre>func NewMat4Add(a, b *Mat4) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix representing the result of adding a to b.
</p>

				
			
				
				<h3 id="NewMat4Frustum">func <a href="/target/mat4.go?s=12133:12209#L217">NewMat4Frustum</a></h3>
				<pre>func NewMat4Frustum(left, right, bottom, top, near, far float64) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix representing the specified frustum.
</p>

				
			
				
				<h3 id="NewMat4Identity">func <a href="/target/mat4.go?s=12350:12384#L224">NewMat4Identity</a></h3>
				<pre>func NewMat4Identity() (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix representing the identity matrix.
</p>

				
			
				
				<h3 id="NewMat4LookAt">func <a href="/target/mat4.go?s=12500:12567#L231">NewMat4LookAt</a></h3>
				<pre>func NewMat4LookAt(bag *Bag, lookTarget, worldUp *Vec3) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix representing the specified look-at matrix.
</p>

				
			
				
				<h3 id="NewMat4Mult1">func <a href="/target/mat4.go?s=12725:12774#L238">NewMat4Mult1</a></h3>
				<pre>func NewMat4Mult1(m *Mat4, v float64) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix representing the result of multiplying all values in m with v.
</p>

				
			
				
				<h3 id="NewMat4Mult4">func <a href="/target/mat4.go?s=13159:13204#L248">NewMat4Mult4</a></h3>
				<pre>func NewMat4Mult4(one, two *Mat4) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix that represents the result of multiplying one with two.
</p>

				
			
				
				<h3 id="NewMat4MultN">func <a href="/target/mat4.go?s=13358:13412#L255">NewMat4MultN</a></h3>
				<pre>func NewMat4MultN(bag *Bag, mats ...*Mat4) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix that represents the result of multiplying all mats with one another.
</p>

				
			
				
				<h3 id="NewMat4Perspective">func <a href="/target/mat4.go?s=13562:13640#L262">NewMat4Perspective</a></h3>
				<pre>func NewMat4Perspective(bag *Bag, fovY, aspect, near, far float64) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix that represents the specified perspective-projection matrix.
</p>

				
			
				
				<h3 id="NewMat4RotationX">func <a href="/target/mat4.go?s=13928:13984#L275">NewMat4RotationX</a></h3>
				<pre>func NewMat4RotationX(bag *Bag, rad float64) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix that representing a rotation of rad radians around the X asis.
</p>

				
			
				
				<h3 id="NewMat4RotationY">func <a href="/target/mat4.go?s=14129:14185#L282">NewMat4RotationY</a></h3>
				<pre>func NewMat4RotationY(bag *Bag, rad float64) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix that representing a rotation of rad radians around the Y asis.
</p>

				
			
				
				<h3 id="NewMat4RotationZ">func <a href="/target/mat4.go?s=14330:14386#L289">NewMat4RotationZ</a></h3>
				<pre>func NewMat4RotationZ(bag *Bag, rad float64) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix that representing a rotation of rad radians around the Z asis.
</p>

				
			
				
				<h3 id="NewMat4Scaling">func <a href="/target/mat4.go?s=14520:14562#L296">NewMat4Scaling</a></h3>
				<pre>func NewMat4Scaling(vec *Vec3) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix that represents a transformation of &#34;scale by vec&#34;.
</p>

				
			
				
				<h3 id="NewMat4Sub">func <a href="/target/mat4.go?s=14664:14703#L303">NewMat4Sub</a></h3>
				<pre>func NewMat4Sub(a, b *Mat4) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix that represents a minus b.
</p>

				
			
				
				<h3 id="NewMat4Translation">func <a href="/target/mat4.go?s=15142:15188#L313">NewMat4Translation</a></h3>
				<pre>func NewMat4Translation(vec *Vec3) (mat *Mat4)</pre>
				<p>
Returns a new 4x4 matrix that represents a transformation of &#34;translate by vec&#34;.
</p>

				
			

			
				
				<h3 id="Mat4.Add">func (*Mat4) <a href="/target/mat4.go?s=374:404#L12">Add</a></h3>
				<pre>func (me *Mat4) Add(mat *Mat4)</pre>
				<p>
Adds mat to this 4x4 matrix.
</p>

				
				
			
				
				<h3 id="Mat4.Clear">func (*Mat4) <a href="/target/mat4.go?s=795:818#L20">Clear</a></h3>
				<pre>func (me *Mat4) Clear()</pre>
				<p>
Zeroes this 4x4 matrix.
</p>

				
				
			
				
				<h3 id="Mat4.Clone">func (*Mat4) <a href="/target/mat4.go?s=889:924#L25">Clone</a></h3>
				<pre>func (me *Mat4) Clone() (mat *Mat4)</pre>
				<p>
Returns a pointer to a newly allocated copy of me.
</p>

				
				
			
				
				<h3 id="Mat4.CopyFrom">func (*Mat4) <a href="/target/mat4.go?s=1020:1055#L32">CopyFrom</a></h3>
				<pre>func (me *Mat4) CopyFrom(mat *Mat4)</pre>
				<p>
Sets this 4x4 matrix to the same values as mat.
</p>

				
				
			
				
				<h3 id="Mat4.CopyTo">func (*Mat4) <a href="/target/mat4.go?s=1124:1157#L37">CopyTo</a></h3>
				<pre>func (me *Mat4) CopyTo(mat *Mat4)</pre>
				<p>
Sets mat to the same values as this 4x4 matrix.
</p>

				
				
			
				
				<h3 id="Mat4.Frustum">func (*Mat4) <a href="/target/mat4.go?s=1235:1303#L42">Frustum</a></h3>
				<pre>func (me *Mat4) Frustum(left, right, bottom, top, near, far float64)</pre>
				<p>
Sets this 4x4 matrix to represent the specified frustum.
</p>

				
				
			
				
				<h3 id="Mat4.Identity">func (*Mat4) <a href="/target/mat4.go?s=1706:1732#L50">Identity</a></h3>
				<pre>func (me *Mat4) Identity()</pre>
				<p>
Sets this 4x4 matrix to the 4x4 identity matrix.
</p>

				
				
			
				
				<h3 id="Mat4.LookAt">func (*Mat4) <a href="/target/mat4.go?s=1807:1866#L55">LookAt</a></h3>
				<pre>func (me *Mat4) LookAt(bag *Bag, lookTarget, worldUp *Vec3)</pre>
				<p>
Sets this 4x4 matrix to the specified look-at matrix.
</p>

				
				
			
				
				<h3 id="Mat4.Mult1">func (*Mat4) <a href="/target/mat4.go?s=3429:3461#L81">Mult1</a></h3>
				<pre>func (me *Mat4) Mult1(v float64)</pre>
				<p>
Multiplies all values in this 4x4 matrix with v.
</p>

				
				
			
				
				<h3 id="Mat4.Perspective">func (*Mat4) <a href="/target/mat4.go?s=3811:3881#L89">Perspective</a></h3>
				<pre>func (me *Mat4) Perspective(bag *Bag, fovY, aspect, near, far float64)</pre>
				<p>
Sets this 4x4 matrix to the specified perspective-projection matrix.
</p>

				
				
			
				
				<h3 id="Mat4.RotationX">func (*Mat4) <a href="/target/mat4.go?s=4764:4812#L108">RotationX</a></h3>
				<pre>func (me *Mat4) RotationX(bag *Bag, rad float64)</pre>
				<p>
Sets this 4x4 matrix to a rotation matrix representing &#34;rotate rad radians around the X asis&#34;.
</p>

				
				
			
				
				<h3 id="Mat4.RotationY">func (*Mat4) <a href="/target/mat4.go?s=5184:5232#L117">RotationY</a></h3>
				<pre>func (me *Mat4) RotationY(bag *Bag, rad float64)</pre>
				<p>
Sets this 4x4 matrix to a rotation matrix representing &#34;rotate rad radians around the Y asis&#34;.
</p>

				
				
			
				
				<h3 id="Mat4.RotationZ">func (*Mat4) <a href="/target/mat4.go?s=5604:5652#L126">RotationZ</a></h3>
				<pre>func (me *Mat4) RotationZ(bag *Bag, rad float64)</pre>
				<p>
Sets this 4x4 matrix to a rotation matrix representing &#34;rotate rad radians around the Z asis&#34;.
</p>

				
				
			
				
				<h3 id="Mat4.Scaling">func (*Mat4) <a href="/target/mat4.go?s=6005:6039#L135">Scaling</a></h3>
				<pre>func (me *Mat4) Scaling(vec *Vec3)</pre>
				<p>
Sets this 4x4 matrix to a transformation matrix representing &#34;scale by vec&#34;
</p>

				
				
			
				
				<h3 id="Mat4.SetFromMult4">func (*Mat4) <a href="/target/mat4.go?s=6294:6338#L143">SetFromMult4</a></h3>
				<pre>func (me *Mat4) SetFromMult4(one, two *Mat4)</pre>
				<p>
Sets this 4x4 matrix to the result of multiplying one with two.
</p>

				
				
			
				
				<h3 id="Mat4.SetFromMultN">func (*Mat4) <a href="/target/mat4.go?s=7648:7701#L151">SetFromMultN</a></h3>
				<pre>func (me *Mat4) SetFromMultN(bag *Bag, mats ...*Mat4)</pre>
				<p>
Sets this 4x4 matrix to the result of multiplying all the specified mats with one another.
</p>

				
				
			
				
				<h3 id="Mat4.Sub">func (*Mat4) <a href="/target/mat4.go?s=10069:10099#L167">Sub</a></h3>
				<pre>func (me *Mat4) Sub(mat *Mat4)</pre>
				<p>
Subtracts mat from this 4x4 matrix.
</p>

				
				
			
				
				<h3 id="Mat4.ToInverseMat3">func (*Mat4) <a href="/target/mat4.go?s=10612:10652#L176">ToInverseMat3</a></h3>
				<pre>func (me *Mat4) ToInverseMat3(mat *Mat3)</pre>
				<p>
Sets the specified 3x3 matrix to the inverse of me.
This method is currently in &#34;not needed right now and not sure if actually correct&#34; limbo.
</p>

				
				
			
				
				<h3 id="Mat4.Translation">func (*Mat4) <a href="/target/mat4.go?s=11237:11275#L192">Translation</a></h3>
				<pre>func (me *Mat4) Translation(vec *Vec3)</pre>
				<p>
Sets this 4x4 matrix to a transformation matrix representing &#34;translate by vec&#34;
</p>

				
				
			
		
			
			
			<h2 id="Quat">type <a href="/target/vec4.go?s=62:102#L1">Quat</a></h2>
			<pre>type Quat struct {
    X, Y, Z, W float64
}</pre>
			<p>
Represents a quaternion.
</p>


			

			

			

			

			
				
				<h3 id="Quat.Clone">func (*Quat) <a href="/target/vec4.go?s=104:137#L2">Clone</a></h3>
				<pre>func (me *Quat) Clone() (q *Quat)</pre>
				
				
				
			
				
				<h3 id="Quat.Conjugate">func (*Quat) <a href="/target/vec4.go?s=244:271#L8">Conjugate</a></h3>
				<pre>func (me *Quat) Conjugate()</pre>
				<p>
Conjugates this quaternion: swaps all signs for the X, Y and Z components only.
</p>

				
				
			
				
				<h3 id="Quat.Conjugated">func (*Quat) <a href="/target/vec4.go?s=403:437#L13">Conjugated</a></h3>
				<pre>func (me *Quat) Conjugated() *Quat</pre>
				<p>
Returns a new quaternion that is the conjugated representation of this quaternion.
</p>

				
				
			
				
				<h3 id="Quat.Length">func (*Quat) <a href="/target/vec4.go?s=526:558#L18">Length</a></h3>
				<pre>func (me *Quat) Length() float64</pre>
				<p>
Returns the length of this quaternion.
</p>

				
				
			
				
				<h3 id="Quat.Magnitude">func (*Quat) <a href="/target/vec4.go?s=679:714#L23">Magnitude</a></h3>
				<pre>func (me *Quat) Magnitude() float64</pre>
				<p>
Returns the magnitude of this quaternion.
</p>

				
				
			
				
				<h3 id="Quat.MultMat4Vec3">func (*Quat) <a href="/target/vec4.go?s=2117:2167#L68">MultMat4Vec3</a></h3>
				<pre>func (me *Quat) MultMat4Vec3(mat *Mat4, vec *Vec3)</pre>
				<p>
Sets this quaternion to the result of multiplying all values in the specified 4x4 matrix with the specified 3D vector.
</p>

				
				
			
				
				<h3 id="Quat.MultMat4Vec4">func (*Quat) <a href="/target/vec4.go?s=2614:2664#L76">MultMat4Vec4</a></h3>
				<pre>func (me *Quat) MultMat4Vec4(mat *Mat4, vec *Quat)</pre>
				<p>
Sets this quaternion to the result of multiplying all values in the specified 4x4 matrix with the specified quaternion.
</p>

				
				
			
				
				<h3 id="Quat.Normalize">func (*Quat) <a href="/target/vec4.go?s=782:817#L28">Normalize</a></h3>
				<pre>func (me *Quat) Normalize(bag *Bag)</pre>
				<p>
Normalizes this quaternion.
</p>

				
				
			
				
				<h3 id="Quat.Normalized">func (*Quat) <a href="/target/vec4.go?s=1111:1157#L39">Normalized</a></h3>
				<pre>func (me *Quat) Normalized(bag *Bag) (q *Quat)</pre>
				<p>
Returns a new quaternion that is the normalized representation of this quaternion.
</p>

				
				
			
				
				<h3 id="Quat.Scale">func (*Quat) <a href="/target/vec4.go?s=1900:1932#L63">Scale</a></h3>
				<pre>func (me *Quat) Scale(v float64)</pre>
				<p>
Multiplies this quaternion&#39;s components with v.
</p>

				
				
			
				
				<h3 id="Quat.SetFromConjugated">func (*Quat) <a href="/target/vec4.go?s=1397:1439#L50">SetFromConjugated</a></h3>
				<pre>func (me *Quat) SetFromConjugated(c *Quat)</pre>
				<p>
Sets this quaternion to the conjugated representation of c.
</p>

				
				
			
				
				<h3 id="Quat.SetFromMult">func (*Quat) <a href="/target/vec4.go?s=1556:1595#L55">SetFromMult</a></h3>
				<pre>func (me *Quat) SetFromMult(l, r *Quat)</pre>
				<p>
Sets this quaternion to the result of multiplying l with r.
</p>

				
				
			
				
				<h3 id="Quat.SetFromMult3">func (*Quat) <a href="/target/vec4.go?s=3085:3131#L84">SetFromMult3</a></h3>
				<pre>func (me *Quat) SetFromMult3(q *Quat, v *Vec3)</pre>
				<p>
Sets this quaternion to the result of multiplying quaternion q with vector v.
</p>

				
				
			
				
				<h3 id="Quat.SetFromMultMat4">func (*Quat) <a href="/target/vec4.go?s=3387:3429#L92">SetFromMultMat4</a></h3>
				<pre>func (me *Quat) SetFromMultMat4(mat *Mat4)</pre>
				<p>
Multiplies this quaternion with the specified matrix.
</p>

				
				
			
		
			
			
			<h2 id="Vec2">type <a href="/target/vec2.go?s=75:107#L1">Vec2</a></h2>
			<pre>type Vec2 struct{ X, Y float64 }</pre>
			<p>
A 2-dimensional vector.
</p>


			

			

			

			

			
				
				<h3 id="Vec2.Div">func (*Vec2) <a href="/target/vec2.go?s=190:226#L2">Div</a></h3>
				<pre>func (me *Vec2) Div(vec *Vec2) *Vec2</pre>
				<p>
Returns a new 2D vector that is the result of dividing this 2D vector by vec.
</p>

				
				
			
				
				<h3 id="Vec2.Dot">func (*Vec2) <a href="/target/vec2.go?s=328:366#L7">Dot</a></h3>
				<pre>func (me *Vec2) Dot(vec *Vec2) float64</pre>
				<p>
Returns the dot product of this 2D vector and vec.
</p>

				
				
			
				
				<h3 id="Vec2.Length">func (*Vec2) <a href="/target/vec2.go?s=453:485#L12">Length</a></h3>
				<pre>func (me *Vec2) Length() float64</pre>
				<p>
Returns the length of this 2D vector.
</p>

				
				
			
				
				<h3 id="Vec2.Magnitude">func (*Vec2) <a href="/target/vec2.go?s=573:608#L17">Magnitude</a></h3>
				<pre>func (me *Vec2) Magnitude() float64</pre>
				<p>
Returns the magnitude of this 2D vector.
</p>

				
				
			
				
				<h3 id="Vec2.Mult">func (*Vec2) <a href="/target/vec2.go?s=731:768#L22">Mult</a></h3>
				<pre>func (me *Vec2) Mult(vec *Vec2) *Vec2</pre>
				<p>
Returns a new 2D vector that is the result of multiplying this 2D vector with vec.
</p>

				
				
			
				
				<h3 id="Vec2.Normalize">func (*Vec2) <a href="/target/vec2.go?s=846:873#L27">Normalize</a></h3>
				<pre>func (me *Vec2) Normalize()</pre>
				<p>
Normalizes this 2D vector.
</p>

				
				
			
				
				<h3 id="Vec2.Normalized">func (*Vec2) <a href="/target/vec2.go?s=1053:1087#L34">Normalized</a></h3>
				<pre>func (me *Vec2) Normalized() *Vec2</pre>
				<p>
Returns a new 2D vector that is the normalized representation of this 2D vector.
</p>

				
				
			
				
				<h3 id="Vec2.NormalizedScaled">func (*Vec2) <a href="/target/vec2.go?s=1296:1356#L41">NormalizedScaled</a></h3>
				<pre>func (me *Vec2) NormalizedScaled(factor float64) (vec *Vec2)</pre>
				<p>
Returns a new 2D vector that is the normalized representation of this 2D vector scaled by factor.
</p>

				
				
			
				
				<h3 id="Vec2.Scale">func (*Vec2) <a href="/target/vec2.go?s=1494:1531#L49">Scale</a></h3>
				<pre>func (me *Vec2) Scale(factor float64)</pre>
				
				
				
			
				
				<h3 id="Vec2.Scaled">func (*Vec2) <a href="/target/vec2.go?s=1652:1696#L54">Scaled</a></h3>
				<pre>func (me *Vec2) Scaled(factor float64) *Vec2</pre>
				<p>
Returns a new 2D vector that represents this 2D vector scaled by factor.
</p>

				
				
			
				
				<h3 id="Vec2.Sub">func (*Vec2) <a href="/target/vec2.go?s=1825:1861#L59">Sub</a></h3>
				<pre>func (me *Vec2) Sub(vec *Vec2) *Vec2</pre>
				<p>
Returns a new 2D vector that represents this 2D vector with vec subtracted.
</p>

				
				
			
		
			
			
			<h2 id="Vec3">type <a href="/target/vec3.go?s=151:188#L3">Vec3</a></h2>
			<pre>type Vec3 struct {
    X, Y, Z float64
}</pre>
			<p>
Represented a 3-dimensional vector.
</p>


			

			

			

			

			
				
				<h3 id="Vec3.Add">func (*Vec3) <a href="/target/vec3.go?s=221:251#L8">Add</a></h3>
				<pre>func (me *Vec3) Add(vec *Vec3)</pre>
				<p>
Adds vec to this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Add1">func (*Vec3) <a href="/target/vec3.go?s=361:394#L13">Add1</a></h3>
				<pre>func (me *Vec3) Add1(val float64)</pre>
				<p>
Adds val to all components of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Add3">func (*Vec3) <a href="/target/vec3.go?s=501:538#L18">Add3</a></h3>
				<pre>func (me *Vec3) Add3(x, y, z float64)</pre>
				<p>
Adds the specified components to this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.AllEqual">func (*Vec3) <a href="/target/vec3.go?s=650:692#L23">AllEqual</a></h3>
				<pre>func (me *Vec3) AllEqual(val float64) bool</pre>
				<p>
Returns true if all components of this 3D vector equal val.
</p>

				
				
			
				
				<h3 id="Vec3.AllGreaterOrEqual">func (*Vec3) <a href="/target/vec3.go?s=821:870#L28">AllGreaterOrEqual</a></h3>
				<pre>func (me *Vec3) AllGreaterOrEqual(vec *Vec3) bool</pre>
				<p>
Returns true if this 3D vector is greater than or equal to vec.
</p>

				
				
			
				
				<h3 id="Vec3.AllInRange">func (*Vec3) <a href="/target/vec3.go?s=1024:1073#L33">AllInRange</a></h3>
				<pre>func (me *Vec3) AllInRange(min, max float64) bool</pre>
				<p>
Returns true if this 3D vector is greater than or equal to min, and less than max.
</p>

				
				
			
				
				<h3 id="Vec3.AllInside">func (*Vec3) <a href="/target/vec3.go?s=1256:1302#L38">AllInside</a></h3>
				<pre>func (me *Vec3) AllInside(min, max *Vec3) bool</pre>
				<p>
Returns true if this 3D vector is greater than min and less than max.
</p>

				
				
			
				
				<h3 id="Vec3.AllLessOrEqual">func (*Vec3) <a href="/target/vec3.go?s=1485:1531#L43">AllLessOrEqual</a></h3>
				<pre>func (me *Vec3) AllLessOrEqual(vec *Vec3) bool</pre>
				<p>
Returns true if this 3D vector is less than or equal to vec.
</p>

				
				
			
				
				<h3 id="Vec3.Cross">func (*Vec3) <a href="/target/vec3.go?s=1687:1725#L48">Cross</a></h3>
				<pre>func (me *Vec3) Cross(vec *Vec3) *Vec3</pre>
				<p>
Returns a new 3D vector that represents the cross-product of this 3D vector and vec.
</p>

				
				
			
				
				<h3 id="Vec3.CrossNormalized">func (*Vec3) <a href="/target/vec3.go?s=1944:1996#L53">CrossNormalized</a></h3>
				<pre>func (me *Vec3) CrossNormalized(vec *Vec3) (r *Vec3)</pre>
				<p>
Returns a new 3D vector that represents the cross-product of this 3D vector and vec, normalized.
</p>

				
				
			
				
				<h3 id="Vec3.Div">func (*Vec3) <a href="/target/vec3.go?s=2249:2285#L61">Div</a></h3>
				<pre>func (me *Vec3) Div(vec *Vec3) *Vec3</pre>
				<p>
Returns a new 3D vector that represents this 3D vector divided by vec.
</p>

				
				
			
				
				<h3 id="Vec3.Div1">func (*Vec3) <a href="/target/vec3.go?s=2438:2477#L66">Div1</a></h3>
				<pre>func (me *Vec3) Div1(val float64) *Vec3</pre>
				<p>
Returns a new 3D vector that represents this 3D vector&#39;s components all divided by val.
</p>

				
				
			
				
				<h3 id="Vec3.Dot">func (*Vec3) <a href="/target/vec3.go?s=2587:2625#L71">Dot</a></h3>
				<pre>func (me *Vec3) Dot(vec *Vec3) float64</pre>
				<p>
Returns the dot product of this 3D vector and vec.
</p>

				
				
			
				
				<h3 id="Vec3.DotSub">func (*Vec3) <a href="/target/vec3.go?s=2756:2804#L76">DotSub</a></h3>
				<pre>func (me *Vec3) DotSub(vec1, vec2 *Vec3) float64</pre>
				<p>
Returns the dot product of this 3D vector and (vec1 minus vec2).
</p>

				
				
			
				
				<h3 id="Vec3.Equals">func (*Vec3) <a href="/target/vec3.go?s=2949:2987#L81">Equals</a></h3>
				<pre>func (me *Vec3) Equals(vec *Vec3) bool</pre>
				<p>
Returns true if this 3D vector equals vec.
</p>

				
				
			
				
				<h3 id="Vec3.Inv">func (*Vec3) <a href="/target/vec3.go?s=3097:3124#L86">Inv</a></h3>
				<pre>func (me *Vec3) Inv() *Vec3</pre>
				<p>
Returns the inverse of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Length">func (*Vec3) <a href="/target/vec3.go?s=3215:3247#L91">Length</a></h3>
				<pre>func (me *Vec3) Length() float64</pre>
				<p>
Returns the length of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Magnitude">func (*Vec3) <a href="/target/vec3.go?s=3351:3386#L96">Magnitude</a></h3>
				<pre>func (me *Vec3) Magnitude() float64</pre>
				<p>
Returns the magnitude of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.MakeFinite">func (*Vec3) <a href="/target/vec3.go?s=3529:3566#L101">MakeFinite</a></h3>
				<pre>func (me *Vec3) MakeFinite(vec *Vec3)</pre>
				<p>
Sets each component of this 3D vector to the corresponding component in vec if the former is infinity.
</p>

				
				
			
				
				<h3 id="Vec3.Max">func (*Vec3) <a href="/target/vec3.go?s=3756:3785#L114">Max</a></h3>
				<pre>func (me *Vec3) Max() float64</pre>
				<p>
Returns the biggest component of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Min">func (*Vec3) <a href="/target/vec3.go?s=3889:3918#L119">Min</a></h3>
				<pre>func (me *Vec3) Min() float64</pre>
				<p>
Returns the smallest component of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Mult">func (*Vec3) <a href="/target/vec3.go?s=4048:4085#L124">Mult</a></h3>
				<pre>func (me *Vec3) Mult(vec *Vec3) *Vec3</pre>
				<p>
Returns a new 3D vector that represents this 3D vector multiplied with vec.
</p>

				
				
			
				
				<h3 id="Vec3.Mult1">func (*Vec3) <a href="/target/vec3.go?s=4243:4283#L129">Mult1</a></h3>
				<pre>func (me *Vec3) Mult1(val float64) *Vec3</pre>
				<p>
Returns a new 3D vector that represents this 3D vector&#39;s components each multipled with val.
</p>

				
				
			
				
				<h3 id="Vec3.Normalize">func (*Vec3) <a href="/target/vec3.go?s=4369:4396#L134">Normalize</a></h3>
				<pre>func (me *Vec3) Normalize()</pre>
				<p>
Normalizes this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Normalized">func (*Vec3) <a href="/target/vec3.go?s=4582:4622#L143">Normalized</a></h3>
				<pre>func (me *Vec3) Normalized() (vec *Vec3)</pre>
				<p>
Returns a new 3D vector that represents this 3D vector, normalized.
</p>

				
				
			
				
				<h3 id="Vec3.NormalizedScaled">func (*Vec3) <a href="/target/vec3.go?s=4861:4921#L153">NormalizedScaled</a></h3>
				<pre>func (me *Vec3) NormalizedScaled(factor float64) (vec *Vec3)</pre>
				<p>
Returns a new 3D vector that represents this 3D vector, normalized, then scaled by factor.
</p>

				
				
			
				
				<h3 id="Vec3.RotateDeg">func (*Vec3) <a href="/target/vec3.go?s=5047:5112#L160">RotateDeg</a></h3>
				<pre>func (me *Vec3) RotateDeg(bag *Bag, angleDeg float64, axis *Vec3)</pre>
				<p>
Rotates this 3D vector angleDeg degrees around the specified axis.
</p>

				
				
			
				
				<h3 id="Vec3.RotateRad">func (*Vec3) <a href="/target/vec3.go?s=5235:5300#L165">RotateRad</a></h3>
				<pre>func (me *Vec3) RotateRad(bag *Bag, angleRad float64, axis *Vec3)</pre>
				<p>
Rotates this 3D vector angleRad radians around the specified axis.
</p>

				
				
			
				
				<h3 id="Vec3.Scale">func (*Vec3) <a href="/target/vec3.go?s=5733:5770#L175">Scale</a></h3>
				<pre>func (me *Vec3) Scale(factor float64)</pre>
				<p>
Scales this 3D vector by factor.
</p>

				
				
			
				
				<h3 id="Vec3.ScaleAdd">func (*Vec3) <a href="/target/vec3.go?s=5885:5928#L180">ScaleAdd</a></h3>
				<pre>func (me *Vec3) ScaleAdd(factor, add *Vec3)</pre>
				<p>
Scales this 3D vector by factor, then adds add.
</p>

				
				
			
				
				<h3 id="Vec3.Scaled">func (*Vec3) <a href="/target/vec3.go?s=6098:6142#L185">Scaled</a></h3>
				<pre>func (me *Vec3) Scaled(factor float64) *Vec3</pre>
				<p>
Returns a new 3D vector that represents this 3D vector scaled by factor.
</p>

				
				
			
				
				<h3 id="Vec3.ScaledAdded">func (*Vec3) <a href="/target/vec3.go?s=6299:6359#L190">ScaledAdded</a></h3>
				<pre>func (me *Vec3) ScaledAdded(factor float64, add *Vec3) *Vec3</pre>
				<p>
Returns a new 3D vector that represents this 3D vector scaled by factor, then add added.
</p>

				
				
			
				
				<h3 id="Vec3.Set">func (*Vec3) <a href="/target/vec3.go?s=6519:6555#L195">Set</a></h3>
				<pre>func (me *Vec3) Set(x, y, z float64)</pre>
				<p>
Sets the components of this 3D vector to the specified value.
</p>

				
				
			
				
				<h3 id="Vec3.SetFrom">func (*Vec3) <a href="/target/vec3.go?s=6675:6709#L200">SetFrom</a></h3>
				<pre>func (me *Vec3) SetFrom(vec *Vec3)</pre>
				<p>
Sets the components of this 3D vector to the same values as the components of vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromAdd">func (*Vec3) <a href="/target/vec3.go?s=6817:6861#L205">SetFromAdd</a></h3>
				<pre>func (me *Vec3) SetFromAdd(vec1, vec2 *Vec3)</pre>
				<p>
Sets this 3D vector to the result of adding vec1 and vec2.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromAddMult">func (*Vec3) <a href="/target/vec3.go?s=7016:7069#L210">SetFromAddMult</a></h3>
				<pre>func (me *Vec3) SetFromAddMult(add, mul1, mul2 *Vec3)</pre>
				<p>
Sets this 3D vector to the result of multiplying mul1 with mul2, then adding add.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromAddMult1">func (*Vec3) <a href="/target/vec3.go?s=7242:7304#L215">SetFromAddMult1</a></h3>
				<pre>func (me *Vec3) SetFromAddMult1(vec1, vec2 *Vec3, mul float64)</pre>
				<p>
Sets this 3D vector to the result of scaling vec2 by mul, then adding vec1.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromCos">func (*Vec3) <a href="/target/vec3.go?s=7486:7523#L220">SetFromCos</a></h3>
				<pre>func (me *Vec3) SetFromCos(vec *Vec3)</pre>
				<p>
Sets each component of this 3D vector to the cosine of the corresponding component in vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromCross">func (*Vec3) <a href="/target/vec3.go?s=7683:7722#L225">SetFromCross</a></h3>
				<pre>func (me *Vec3) SetFromCross(vec *Vec3)</pre>
				<p>
Modifies this Vec3 to represent the cross-product of its previous value and vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromCrossOf">func (*Vec3) <a href="/target/vec3.go?s=7876:7922#L230">SetFromCrossOf</a></h3>
				<pre>func (me *Vec3) SetFromCrossOf(one, two *Vec3)</pre>
				<p>
Sets me to the cross product of one and two.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromDegToRad">func (*Vec3) <a href="/target/vec3.go?s=8166:8208#L235">SetFromDegToRad</a></h3>
				<pre>func (me *Vec3) SetFromDegToRad(deg *Vec3)</pre>
				<p>
Sets each component of this 3D vector to the radian equivalent of the degree angle stored in the corresponding component in vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromEpsilon32">func (*Vec3) <a href="/target/vec3.go?s=8388:8422#L240">SetFromEpsilon32</a></h3>
				<pre>func (me *Vec3) SetFromEpsilon32()</pre>
				<p>
Sets each component of this 3D vector to Epsilon32 if it is 0 or greater but smaller than Epsilon32.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromEpsilon64">func (*Vec3) <a href="/target/vec3.go?s=8718:8752#L253">SetFromEpsilon64</a></h3>
				<pre>func (me *Vec3) SetFromEpsilon64()</pre>
				<p>
Sets each component of this 3D vector to Epsilon64 if it is 0 or greater but smaller than Epsilon64.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromInv">func (*Vec3) <a href="/target/vec3.go?s=8990:9027#L266">SetFromInv</a></h3>
				<pre>func (me *Vec3) SetFromInv(vec *Vec3)</pre>
				<p>
Sets this 3D vector to the inverse of vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromMult">func (*Vec3) <a href="/target/vec3.go?s=9142:9183#L271">SetFromMult</a></h3>
				<pre>func (me *Vec3) SetFromMult(v1, v2 *Vec3)</pre>
				<p>
Sets this 3D vector to the result of v1 multiplied with v2.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromMult1">func (*Vec3) <a href="/target/vec3.go?s=9300:9352#L276">SetFromMult1</a></h3>
				<pre>func (me *Vec3) SetFromMult1(vec *Vec3, mul float64)</pre>
				<p>
Sets this 3D vector to the result of vec scaled by mul.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromMult1Sub">func (*Vec3) <a href="/target/vec3.go?s=9484:9546#L281">SetFromMult1Sub</a></h3>
				<pre>func (me *Vec3) SetFromMult1Sub(vec1, vec2 *Vec3, mul float64)</pre>
				<p>
Sets this 3D vector to the result of (vec1 minus vec2), scaled by mul.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromNeg">func (*Vec3) <a href="/target/vec3.go?s=9701:9738#L286">SetFromNeg</a></h3>
				<pre>func (me *Vec3) SetFromNeg(vec *Vec3)</pre>
				<p>
Sets this 3D vector to vec with each component&#39;s sign reversed.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromNormalized">func (*Vec3) <a href="/target/vec3.go?s=9833:9877#L291">SetFromNormalized</a></h3>
				<pre>func (me *Vec3) SetFromNormalized(vec *Vec3)</pre>
				<p>
Sets me to the result  of normalizing vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromRotation">func (*Vec3) <a href="/target/vec3.go?s=10037:10095#L298">SetFromRotation</a></h3>
				<pre>func (me *Vec3) SetFromRotation(pos, rotCos, rotSin *Vec3)</pre>
				<p>
Sets this 3D vector to pos rotated as expressed in rotCos and rotSin.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSin">func (*Vec3) <a href="/target/vec3.go?s=10344:10381#L306">SetFromSin</a></h3>
				<pre>func (me *Vec3) SetFromSin(vec *Vec3)</pre>
				<p>
Sets this 3D vector to the sine of vec.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromStep">func (*Vec3) <a href="/target/vec3.go?s=10603:10663#L311">SetFromStep</a></h3>
				<pre>func (me *Vec3) SetFromStep(edge float64, vec, v0, v1 *Vec3)</pre>
				<p>
Sets each component of this 3D vector to the corresponding component in v0 if it is less than edge, else to the corresponding component in v1.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSub">func (*Vec3) <a href="/target/vec3.go?s=10906:10950#L330">SetFromSub</a></h3>
				<pre>func (me *Vec3) SetFromSub(vec1, vec2 *Vec3)</pre>
				<p>
Sets this 3D vector to the result of vec1 minus vec2.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSubMult">func (*Vec3) <a href="/target/vec3.go?s=11094:11147#L335">SetFromSubMult</a></h3>
				<pre>func (me *Vec3) SetFromSubMult(sub1, sub2, mul *Vec3)</pre>
				<p>
Sets this 3D vector to the result of (sub1 minus sub2), scaled by mul.
</p>

				
				
			
				
				<h3 id="Vec3.SetFromSubMult1">func (*Vec3) <a href="/target/vec3.go?s=11314:11376#L340">SetFromSubMult1</a></h3>
				<pre>func (me *Vec3) SetFromSubMult1(vec1, vec2 *Vec3, mul float64)</pre>
				<p>
Sets this 3D vector to the result of sub1 minus (vec2 scaled by mul).
</p>

				
				
			
				
				<h3 id="Vec3.Sign">func (*Vec3) <a href="/target/vec3.go?s=11572:11600#L345">Sign</a></h3>
				<pre>func (me *Vec3) Sign() *Vec3</pre>
				<p>
Returns a 3D vector where each component indicates the sign of this 3D vector&#39;s corresponding component.
</p>

				
				
			
				
				<h3 id="Vec3.String">func (*Vec3) <a href="/target/vec3.go?s=11710:11741#L350">String</a></h3>
				<pre>func (me *Vec3) String() string</pre>
				<p>
Returns a string representation of this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.Sub">func (*Vec3) <a href="/target/vec3.go?s=11886:11922#L355">Sub</a></h3>
				<pre>func (me *Vec3) Sub(vec *Vec3) *Vec3</pre>
				<p>
Returns a new 3D vector that represents (this 3D vector minus vec).
</p>

				
				
			
				
				<h3 id="Vec3.SubDivMult">func (*Vec3) <a href="/target/vec3.go?s=12091:12144#L360">SubDivMult</a></h3>
				<pre>func (me *Vec3) SubDivMult(sub, div, mul *Vec3) *Vec3</pre>
				<p>
Returns a new 3D vector that represents (this 3D vector minus sub) divided by div, multiplied with mul.
</p>

				
				
			
				
				<h3 id="Vec3.SubDot">func (*Vec3) <a href="/target/vec3.go?s=12323:12364#L365">SubDot</a></h3>
				<pre>func (me *Vec3) SubDot(vec *Vec3) float64</pre>
				<p>
Returns the dot product of (this 3D vector minus vec)
</p>

				
				
			
				
				<h3 id="Vec3.SubFloorDivMult">func (*Vec3) <a href="/target/vec3.go?s=12607:12667#L370">SubFloorDivMult</a></h3>
				<pre>func (me *Vec3) SubFloorDivMult(floorDiv, mul float64) *Vec3</pre>
				<p>
Returns a new 3D vector that represents the result of (this 3D vector divided by floorDiv) floored, then scaled by mul.
</p>

				
				
			
				
				<h3 id="Vec3.SubFrom">func (*Vec3) <a href="/target/vec3.go?s=12865:12907#L375">SubFrom</a></h3>
				<pre>func (me *Vec3) SubFrom(val float64) *Vec3</pre>
				<p>
Returns a new 3D vector that represents (val minus this 3D vector).
</p>

				
				
			
				
				<h3 id="Vec3.SubMult">func (*Vec3) <a href="/target/vec3.go?s=13049:13102#L380">SubMult</a></h3>
				<pre>func (me *Vec3) SubMult(vec *Vec3, val float64) *Vec3</pre>
				<p>
Returns a new 3D vector that represents (this 3D vector minus vec), scaled by val.
</p>

				
				
			
				
				<h3 id="Vec3.SubVec">func (*Vec3) <a href="/target/vec3.go?s=13226:13259#L385">SubVec</a></h3>
				<pre>func (me *Vec3) SubVec(vec *Vec3)</pre>
				<p>
Subtracts vec from this 3D vector.
</p>

				
				
			
				
				<h3 id="Vec3.SwapSigns">func (*Vec3) <a href="/target/vec3.go?s=13381:13408#L390">SwapSigns</a></h3>
				<pre>func (me *Vec3) SwapSigns()</pre>
				<p>
Reverses the sign of each of this 3D vector&#39;s components.
</p>

				
				
			
		
		</div>
	

	








		</div></div>
	</body>
</html>