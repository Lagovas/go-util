<html>
	<head>
		<title>Package github.com/metaleap/go-util/slice</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/metaleap/go-util/slice</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/metaleap/go-util/slice"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
&#39;Pseudo-generic&#39; typed-slice utilities
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#BoolAppendUnique">func BoolAppendUnique(ref *[]bool, v bool)</a></dd>
			
				
				<dd><a href="#BoolAt">func BoolAt(slice []bool, val bool) int</a></dd>
			
				
				<dd><a href="#BoolEnsureCap">func BoolEnsureCap(ref *[]bool, capacity int)</a></dd>
			
				
				<dd><a href="#BoolEnsureLen">func BoolEnsureLen(ref *[]bool, length int)</a></dd>
			
				
				<dd><a href="#BoolEquivalent">func BoolEquivalent(one, two []bool) bool</a></dd>
			
				
				<dd><a href="#BoolHas">func BoolHas(slice []bool, val bool) bool</a></dd>
			
				
				<dd><a href="#BoolHasAny">func BoolHasAny(slice []bool, vals ...bool) bool</a></dd>
			
				
				<dd><a href="#BoolRemove">func BoolRemove(ref *[]bool, v bool, all bool)</a></dd>
			
				
				<dd><a href="#BoolSetCap">func BoolSetCap(ref *[]bool, capacity int)</a></dd>
			
				
				<dd><a href="#BoolSetLen">func BoolSetLen(ref *[]bool, length int)</a></dd>
			
				
				<dd><a href="#BoolWithout">func BoolWithout(slice []bool, keepOrder bool, withoutVals ...bool) []bool</a></dd>
			
				
				<dd><a href="#F64AppendUnique">func F64AppendUnique(ref *[]float64, v float64)</a></dd>
			
				
				<dd><a href="#F64At">func F64At(slice []float64, val float64) int</a></dd>
			
				
				<dd><a href="#F64EnsureCap">func F64EnsureCap(ref *[]float64, capacity int)</a></dd>
			
				
				<dd><a href="#F64EnsureLen">func F64EnsureLen(ref *[]float64, length int)</a></dd>
			
				
				<dd><a href="#F64Equivalent">func F64Equivalent(one, two []float64) bool</a></dd>
			
				
				<dd><a href="#F64Has">func F64Has(slice []float64, val float64) bool</a></dd>
			
				
				<dd><a href="#F64HasAny">func F64HasAny(slice []float64, vals ...float64) bool</a></dd>
			
				
				<dd><a href="#F64Remove">func F64Remove(ref *[]float64, v float64, all bool)</a></dd>
			
				
				<dd><a href="#F64SetCap">func F64SetCap(ref *[]float64, capacity int)</a></dd>
			
				
				<dd><a href="#F64SetLen">func F64SetLen(ref *[]float64, length int)</a></dd>
			
				
				<dd><a href="#F64Without">func F64Without(slice []float64, keepOrder bool, withoutVals ...float64) []float64</a></dd>
			
				
				<dd><a href="#IntAppendUnique">func IntAppendUnique(ref *[]int, v int)</a></dd>
			
				
				<dd><a href="#IntAt">func IntAt(slice []int, val int) int</a></dd>
			
				
				<dd><a href="#IntEnsureCap">func IntEnsureCap(ref *[]int, capacity int)</a></dd>
			
				
				<dd><a href="#IntEnsureLen">func IntEnsureLen(ref *[]int, length int)</a></dd>
			
				
				<dd><a href="#IntEquivalent">func IntEquivalent(one, two []int) bool</a></dd>
			
				
				<dd><a href="#IntHas">func IntHas(slice []int, val int) bool</a></dd>
			
				
				<dd><a href="#IntHasAny">func IntHasAny(slice []int, vals ...int) bool</a></dd>
			
				
				<dd><a href="#IntRemove">func IntRemove(ref *[]int, v int, all bool)</a></dd>
			
				
				<dd><a href="#IntSetCap">func IntSetCap(ref *[]int, capacity int)</a></dd>
			
				
				<dd><a href="#IntSetLen">func IntSetLen(ref *[]int, length int)</a></dd>
			
				
				<dd><a href="#IntWithout">func IntWithout(slice []int, keepOrder bool, withoutVals ...int) []int</a></dd>
			
				
				<dd><a href="#StrAppendUnique">func StrAppendUnique(ref *[]string, v string)</a></dd>
			
				
				<dd><a href="#StrAt">func StrAt(slice []string, val string) int</a></dd>
			
				
				<dd><a href="#StrAtIgnoreCase">func StrAtIgnoreCase(vals []string, val string) int</a></dd>
			
				
				<dd><a href="#StrEnsureCap">func StrEnsureCap(ref *[]string, capacity int)</a></dd>
			
				
				<dd><a href="#StrEnsureLen">func StrEnsureLen(ref *[]string, length int)</a></dd>
			
				
				<dd><a href="#StrEquivalent">func StrEquivalent(one, two []string) bool</a></dd>
			
				
				<dd><a href="#StrHas">func StrHas(slice []string, val string) bool</a></dd>
			
				
				<dd><a href="#StrHasAny">func StrHasAny(slice []string, vals ...string) bool</a></dd>
			
				
				<dd><a href="#StrHasIgnoreCase">func StrHasIgnoreCase(vals []string, val string) bool</a></dd>
			
				
				<dd><a href="#StrRemove">func StrRemove(ref *[]string, v string, all bool)</a></dd>
			
				
				<dd><a href="#StrSetCap">func StrSetCap(ref *[]string, capacity int)</a></dd>
			
				
				<dd><a href="#StrSetLen">func StrSetLen(ref *[]string, length int)</a></dd>
			
				
				<dd><a href="#StrWithout">func StrWithout(slice []string, keepOrder bool, withoutVals ...string) []string</a></dd>
			
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/bool.gt.go">bool.gt.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/f64.gt.go">f64.gt.go</a>
			
				<a href="/target/int.gt.go">int.gt.go</a>
			
				<a href="/target/str.gt.go">str.gt.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		
		
		
			
			
			<h2 id="BoolAppendUnique">func <a href="/target/bool.gt.go?s=109:151#L1">BoolAppendUnique</a></h2>
			<pre>func BoolAppendUnique(ref *[]<a href="/pkg/builtin/#bool">bool</a>, v <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
Appends v to sl only if sl does not already contain v.
</p>

			
		
			
			
			<h2 id="BoolAt">func <a href="/target/bool.gt.go?s=281:320#L6">BoolAt</a></h2>
			<pre>func BoolAt(slice []<a href="/pkg/builtin/#bool">bool</a>, val <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Returns the position of val in slice.
</p>

			
		
			
			
			<h2 id="BoolEnsureCap">func <a href="/target/bool.gt.go?s=495:540#L16">BoolEnsureCap</a></h2>
			<pre>func BoolEnsureCap(ref *[]<a href="/pkg/builtin/#bool">bool</a>, capacity <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Calls BoolSetCap() only if the current capacity of *ref is less than the specified capacity.
</p>

			
		
			
			
			<h2 id="BoolEnsureLen">func <a href="/target/bool.gt.go?s=694:737#L23">BoolEnsureLen</a></h2>
			<pre>func BoolEnsureLen(ref *[]<a href="/pkg/builtin/#bool">bool</a>, length <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Calls BoolSetLen only if the current length of *ref is less than the specified length.
</p>

			
		
			
			
			<h2 id="BoolEquivalent">func <a href="/target/bool.gt.go?s=883:924#L30">BoolEquivalent</a></h2>
			<pre>func BoolEquivalent(one, two []<a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if one and two only contain identical values, regardless of ordering.
</p>

			
		
			
			
			<h2 id="BoolHas">func <a href="/target/bool.gt.go?s=1098:1139#L43">BoolHas</a></h2>
			<pre>func BoolHas(slice []<a href="/pkg/builtin/#bool">bool</a>, val <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if val is in slice.
</p>

			
		
			
			
			<h2 id="BoolHasAny">func <a href="/target/bool.gt.go?s=1245:1293#L48">BoolHasAny</a></h2>
			<pre>func BoolHasAny(slice []<a href="/pkg/builtin/#bool">bool</a>, vals ...<a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns whether one of the specified vals is contained in slice.
</p>

			
		
			
			
			<h2 id="BoolRemove">func <a href="/target/bool.gt.go?s=1507:1553#L60">BoolRemove</a></h2>
			<pre>func BoolRemove(ref *[]<a href="/pkg/builtin/#bool">bool</a>, v <a href="/pkg/builtin/#bool">bool</a>, all <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
Removes the first occurrence of v encountered in *ref, or all occurrences if all is true.
</p>

			
		
			
			
			<h2 id="BoolSetCap">func <a href="/target/bool.gt.go?s=1790:1832#L73">BoolSetCap</a></h2>
			<pre>func BoolSetCap(ref *[]<a href="/pkg/builtin/#bool">bool</a>, capacity <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Sets *ref to a copy of *ref with the specified capacity.
</p>

			
		
			
			
			<h2 id="BoolSetLen">func <a href="/target/bool.gt.go?s=1964:2004#L80">BoolSetLen</a></h2>
			<pre>func BoolSetLen(ref *[]<a href="/pkg/builtin/#bool">bool</a>, length <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Sets *ref to a copy of *ref with the specified length.
</p>

			
		
			
			
			<h2 id="BoolWithout">func <a href="/target/bool.gt.go?s=2104:2178#L87">BoolWithout</a></h2>
			<pre>func BoolWithout(slice []<a href="/pkg/builtin/#bool">bool</a>, keepOrder <a href="/pkg/builtin/#bool">bool</a>, withoutVals ...<a href="/pkg/builtin/#bool">bool</a>) []<a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Removes all withoutVals from slice.
</p>

			
		
			
			
			<h2 id="F64AppendUnique">func <a href="/target/f64.gt.go?s=111:158#L1">F64AppendUnique</a></h2>
			<pre>func F64AppendUnique(ref *[]<a href="/pkg/builtin/#float64">float64</a>, v <a href="/pkg/builtin/#float64">float64</a>)</pre>
			<p>
Appends v to sl only if sl does not already contain v.
</p>

			
		
			
			
			<h2 id="F64At">func <a href="/target/f64.gt.go?s=288:332#L6">F64At</a></h2>
			<pre>func F64At(slice []<a href="/pkg/builtin/#float64">float64</a>, val <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Returns the position of val in slice.
</p>

			
		
			
			
			<h2 id="F64EnsureCap">func <a href="/target/f64.gt.go?s=506:553#L16">F64EnsureCap</a></h2>
			<pre>func F64EnsureCap(ref *[]<a href="/pkg/builtin/#float64">float64</a>, capacity <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Calls F64SetCap() only if the current capacity of *ref is less than the specified capacity.
</p>

			
		
			
			
			<h2 id="F64EnsureLen">func <a href="/target/f64.gt.go?s=705:750#L23">F64EnsureLen</a></h2>
			<pre>func F64EnsureLen(ref *[]<a href="/pkg/builtin/#float64">float64</a>, length <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Calls F64SetLen only if the current length of *ref is less than the specified length.
</p>

			
		
			
			
			<h2 id="F64Equivalent">func <a href="/target/f64.gt.go?s=895:938#L30">F64Equivalent</a></h2>
			<pre>func F64Equivalent(one, two []<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if one and two only contain identical values, regardless of ordering.
</p>

			
		
			
			
			<h2 id="F64Has">func <a href="/target/f64.gt.go?s=1111:1157#L43">F64Has</a></h2>
			<pre>func F64Has(slice []<a href="/pkg/builtin/#float64">float64</a>, val <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if val is in slice.
</p>

			
		
			
			
			<h2 id="F64HasAny">func <a href="/target/f64.gt.go?s=1262:1315#L48">F64HasAny</a></h2>
			<pre>func F64HasAny(slice []<a href="/pkg/builtin/#float64">float64</a>, vals ...<a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns whether one of the specified vals is contained in slice.
</p>

			
		
			
			
			<h2 id="F64Remove">func <a href="/target/f64.gt.go?s=1529:1580#L60">F64Remove</a></h2>
			<pre>func F64Remove(ref *[]<a href="/pkg/builtin/#float64">float64</a>, v <a href="/pkg/builtin/#float64">float64</a>, all <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
Removes the first occurrence of v encountered in *ref, or all occurrences if all is true.
</p>

			
		
			
			
			<h2 id="F64SetCap">func <a href="/target/f64.gt.go?s=1817:1861#L73">F64SetCap</a></h2>
			<pre>func F64SetCap(ref *[]<a href="/pkg/builtin/#float64">float64</a>, capacity <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Sets *ref to a copy of *ref with the specified capacity.
</p>

			
		
			
			
			<h2 id="F64SetLen">func <a href="/target/f64.gt.go?s=1996:2038#L80">F64SetLen</a></h2>
			<pre>func F64SetLen(ref *[]<a href="/pkg/builtin/#float64">float64</a>, length <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Sets *ref to a copy of *ref with the specified length.
</p>

			
		
			
			
			<h2 id="F64Without">func <a href="/target/f64.gt.go?s=2141:2223#L87">F64Without</a></h2>
			<pre>func F64Without(slice []<a href="/pkg/builtin/#float64">float64</a>, keepOrder <a href="/pkg/builtin/#bool">bool</a>, withoutVals ...<a href="/pkg/builtin/#float64">float64</a>) []<a href="/pkg/builtin/#float64">float64</a></pre>
			<p>
Removes all withoutVals from slice.
</p>

			
		
			
			
			<h2 id="IntAppendUnique">func <a href="/target/int.gt.go?s=107:146#L1">IntAppendUnique</a></h2>
			<pre>func IntAppendUnique(ref *[]<a href="/pkg/builtin/#int">int</a>, v <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Appends v to sl only if sl does not already contain v.
</p>

			
		
			
			
			<h2 id="IntAt">func <a href="/target/int.gt.go?s=276:312#L6">IntAt</a></h2>
			<pre>func IntAt(slice []<a href="/pkg/builtin/#int">int</a>, val <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Returns the position of val in slice.
</p>

			
		
			
			
			<h2 id="IntEnsureCap">func <a href="/target/int.gt.go?s=486:529#L16">IntEnsureCap</a></h2>
			<pre>func IntEnsureCap(ref *[]<a href="/pkg/builtin/#int">int</a>, capacity <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Calls IntSetCap() only if the current capacity of *ref is less than the specified capacity.
</p>

			
		
			
			
			<h2 id="IntEnsureLen">func <a href="/target/int.gt.go?s=681:722#L23">IntEnsureLen</a></h2>
			<pre>func IntEnsureLen(ref *[]<a href="/pkg/builtin/#int">int</a>, length <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Calls IntSetLen only if the current length of *ref is less than the specified length.
</p>

			
		
			
			
			<h2 id="IntEquivalent">func <a href="/target/int.gt.go?s=867:906#L30">IntEquivalent</a></h2>
			<pre>func IntEquivalent(one, two []<a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if one and two only contain identical values, regardless of ordering.
</p>

			
		
			
			
			<h2 id="IntHas">func <a href="/target/int.gt.go?s=1079:1117#L43">IntHas</a></h2>
			<pre>func IntHas(slice []<a href="/pkg/builtin/#int">int</a>, val <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if val is in slice.
</p>

			
		
			
			
			<h2 id="IntHasAny">func <a href="/target/int.gt.go?s=1222:1267#L48">IntHasAny</a></h2>
			<pre>func IntHasAny(slice []<a href="/pkg/builtin/#int">int</a>, vals ...<a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns whether one of the specified vals is contained in slice.
</p>

			
		
			
			
			<h2 id="IntRemove">func <a href="/target/int.gt.go?s=1481:1524#L60">IntRemove</a></h2>
			<pre>func IntRemove(ref *[]<a href="/pkg/builtin/#int">int</a>, v <a href="/pkg/builtin/#int">int</a>, all <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
Removes the first occurrence of v encountered in *ref, or all occurrences if all is true.
</p>

			
		
			
			
			<h2 id="IntSetCap">func <a href="/target/int.gt.go?s=1761:1801#L73">IntSetCap</a></h2>
			<pre>func IntSetCap(ref *[]<a href="/pkg/builtin/#int">int</a>, capacity <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Sets *ref to a copy of *ref with the specified capacity.
</p>

			
		
			
			
			<h2 id="IntSetLen">func <a href="/target/int.gt.go?s=1932:1970#L80">IntSetLen</a></h2>
			<pre>func IntSetLen(ref *[]<a href="/pkg/builtin/#int">int</a>, length <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Sets *ref to a copy of *ref with the specified length.
</p>

			
		
			
			
			<h2 id="IntWithout">func <a href="/target/int.gt.go?s=2069:2139#L87">IntWithout</a></h2>
			<pre>func IntWithout(slice []<a href="/pkg/builtin/#int">int</a>, keepOrder <a href="/pkg/builtin/#bool">bool</a>, withoutVals ...<a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#int">int</a></pre>
			<p>
Removes all withoutVals from slice.
</p>

			
		
			
			
			<h2 id="StrAppendUnique">func <a href="/target/str.gt.go?s=540:585#L16">StrAppendUnique</a></h2>
			<pre>func StrAppendUnique(ref *[]<a href="/pkg/builtin/#string">string</a>, v <a href="/pkg/builtin/#string">string</a>)</pre>
			<p>
Appends v to sl only if sl does not already contain v.
</p>

			
		
			
			
			<h2 id="StrAt">func <a href="/target/str.gt.go?s=715:757#L26">StrAt</a></h2>
			<pre>func StrAt(slice []<a href="/pkg/builtin/#string">string</a>, val <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Returns the position of val in slice.
</p>

			
		
			
			
			<h2 id="StrAtIgnoreCase">func <a href="/target/str.gt.go?s=101:152#L1">StrAtIgnoreCase</a></h2>
			<pre>func StrAtIgnoreCase(vals []<a href="/pkg/builtin/#string">string</a>, val <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Returns the position of lower-case val in lower-case vals.
</p>

			
		
			
			
			<h2 id="StrEnsureCap">func <a href="/target/str.gt.go?s=931:977#L36">StrEnsureCap</a></h2>
			<pre>func StrEnsureCap(ref *[]<a href="/pkg/builtin/#string">string</a>, capacity <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Calls StrSetCap() only if the current capacity of *ref is less than the specified capacity.
</p>

			
		
			
			
			<h2 id="StrEnsureLen">func <a href="/target/str.gt.go?s=1129:1173#L43">StrEnsureLen</a></h2>
			<pre>func StrEnsureLen(ref *[]<a href="/pkg/builtin/#string">string</a>, length <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Calls StrSetLen only if the current length of *ref is less than the specified length.
</p>

			
		
			
			
			<h2 id="StrEquivalent">func <a href="/target/str.gt.go?s=1318:1360#L50">StrEquivalent</a></h2>
			<pre>func StrEquivalent(one, two []<a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if one and two only contain identical values, regardless of ordering.
</p>

			
		
			
			
			<h2 id="StrHas">func <a href="/target/str.gt.go?s=1533:1577#L63">StrHas</a></h2>
			<pre>func StrHas(slice []<a href="/pkg/builtin/#string">string</a>, val <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if val is in slice.
</p>

			
		
			
			
			<h2 id="StrHasAny">func <a href="/target/str.gt.go?s=1682:1733#L68">StrHasAny</a></h2>
			<pre>func StrHasAny(slice []<a href="/pkg/builtin/#string">string</a>, vals ...<a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns whether one of the specified vals is contained in slice.
</p>

			
		
			
			
			<h2 id="StrHasIgnoreCase">func <a href="/target/str.gt.go?s=347:400#L9">StrHasIgnoreCase</a></h2>
			<pre>func StrHasIgnoreCase(vals []<a href="/pkg/builtin/#string">string</a>, val <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>
Returns true if lower-case val is in lower-case vals.
</p>

			
		
			
			
			<h2 id="StrRemove">func <a href="/target/str.gt.go?s=1947:1996#L80">StrRemove</a></h2>
			<pre>func StrRemove(ref *[]<a href="/pkg/builtin/#string">string</a>, v <a href="/pkg/builtin/#string">string</a>, all <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
Removes the first occurrence of v encountered in *ref, or all occurrences if all is true.
</p>

			
		
			
			
			<h2 id="StrSetCap">func <a href="/target/str.gt.go?s=2233:2276#L93">StrSetCap</a></h2>
			<pre>func StrSetCap(ref *[]<a href="/pkg/builtin/#string">string</a>, capacity <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Sets *ref to a copy of *ref with the specified capacity.
</p>

			
		
			
			
			<h2 id="StrSetLen">func <a href="/target/str.gt.go?s=2410:2451#L100">StrSetLen</a></h2>
			<pre>func StrSetLen(ref *[]<a href="/pkg/builtin/#string">string</a>, length <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>
Sets *ref to a copy of *ref with the specified length.
</p>

			
		
			
			
			<h2 id="StrWithout">func <a href="/target/str.gt.go?s=2553:2632#L107">StrWithout</a></h2>
			<pre>func StrWithout(slice []<a href="/pkg/builtin/#string">string</a>, keepOrder <a href="/pkg/builtin/#bool">bool</a>, withoutVals ...<a href="/pkg/builtin/#string">string</a>) []<a href="/pkg/builtin/#string">string</a></pre>
			<p>
Removes all withoutVals from slice.
</p>

			
		
		
	

	








		</div></div>
	</body>
</html>