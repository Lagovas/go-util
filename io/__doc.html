<html>
	<head>
		<title>Package github.com/metaleap/go-util/io</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/metaleap/go-util/io</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/metaleap/go-util/io"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Various line-savers for common I/O needs.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#ClearDirectory">func ClearDirectory(path string, keepNamePatterns ...string) (err error)</a></dd>
			
				
				<dd><a href="#CopyAll">func CopyAll(srcDirPath, destDirPath string, skipDirs *ustr.Matcher) (err error)</a></dd>
			
				
				<dd><a href="#CopyFile">func CopyFile(srcFilePath, destFilePath string) (err error)</a></dd>
			
				
				<dd><a href="#DirExists">func DirExists(path string) bool</a></dd>
			
				
				<dd><a href="#EnsureDirExists">func EnsureDirExists(path string) (err error)</a></dd>
			
				
				<dd><a href="#ExtractZipFile">func ExtractZipFile(zipFilePath, targetDirPath string, deleteZipFile bool, fileNamesPrefix string, fileNamesToExtract ...string) error</a></dd>
			
				
				<dd><a href="#FileExists">func FileExists(path string) bool</a></dd>
			
				
				<dd><a href="#FindFileInfo">func FindFileInfo(dirPath string, fileBaseName string, fileExts []string, tryLower bool, tryUpper bool) (fullFilePath string, fileInfo *os.FileInfo)</a></dd>
			
				
				<dd><a href="#ReadBinaryFile">func ReadBinaryFile(filePath string, panicOnError bool) []byte</a></dd>
			
				
				<dd><a href="#ReadFromBinary">func ReadFromBinary(readSeeker io.ReadSeeker, offset int64, byteOrder binary.ByteOrder, ptr interface{}) bool</a></dd>
			
				
				<dd><a href="#ReadTextFile">func ReadTextFile(filePath string, panicOnError bool, defVal string) string</a></dd>
			
				
				<dd><a href="#SaveToFile">func SaveToFile(r io.Reader, filename string) (err error)</a></dd>
			
				
				<dd><a href="#WalkerVisitorNoop">func WalkerVisitorNoop(_ *DirWalker, _ string, _ os.FileInfo) bool</a></dd>
			
				
				<dd><a href="#WriteBinaryFile">func WriteBinaryFile(filePath string, contents []byte) error</a></dd>
			
				
				<dd><a href="#WriteTextFile">func WriteTextFile(filePath, contents string) error</a></dd>
			
			
				
				<dd><a href="#DirWalker">type DirWalker</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewDirWalker">func NewDirWalker(dirVisitor, fileVisitor WalkerVisitor) (me *DirWalker)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DirWalker.Walk">func (me *DirWalker) Walk(dirPath string) (errs []error)</a></dd>
				
			
				
				<dd><a href="#WalkerVisitor">type WalkerVisitor</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWalkerVisitor_IsNewerThan">func NewWalkerVisitor_IsNewerThan(testTime time.Time, fileTime *time.Time) WalkerVisitor</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/io.go">io.go</a>
			
				<a href="/target/walker.go">walker.go</a>
			
			</span>
			</p>
		
	
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span class="comment">//	The permission bits used in EnsureDirExists(), WriteBinaryFile() and WriteTextFile()</span>
    ModePerm = os.ModePerm
)</pre>
				
			
		
		
			
			
			<h2 id="ClearDirectory">func <a href="/target/io.go?s=389:461#L11">ClearDirectory</a></h2>
			<pre>func ClearDirectory(path string, keepNamePatterns ...string) (err error)</pre>
			<p>
Removes any children contained in path, except those whose name matches any of the specified keepNamePatterns.
</p>

			
		
			
			
			<h2 id="CopyAll">func <a href="/target/io.go?s=937:1017#L28">CopyAll</a></h2>
			<pre>func CopyAll(srcDirPath, destDirPath string, skipDirs *ustr.Matcher) (err error)</pre>
			<p>
Copies all files and directories inside srcDirPath to destDirPath.
All sub-directories whose name is matched by skipDirs (optional) are skipped.
</p>

			
		
			
			
			<h2 id="CopyFile">func <a href="/target/io.go?s=1632:1691#L49">CopyFile</a></h2>
			<pre>func CopyFile(srcFilePath, destFilePath string) (err error)</pre>
			<p>
Performs an io.Copy from the specified local source file to the specified local destination file.
</p>

			
		
			
			
			<h2 id="DirExists">func <a href="/target/io.go?s=1902:1934#L60">DirExists</a></h2>
			<pre>func DirExists(path string) bool</pre>
			<p>
Returns true if a directory exists at the specified path.
</p>

			
		
			
			
			<h2 id="EnsureDirExists">func <a href="/target/io.go?s=2103:2148#L68">EnsureDirExists</a></h2>
			<pre>func EnsureDirExists(path string) (err error)</pre>
			<p>
If a directory does not exist at the specified path, attempts to create it.
</p>

			
		
			
			
			<h2 id="ExtractZipFile">func <a href="/target/io.go?s=2554:2688#L81">ExtractZipFile</a></h2>
			<pre>func ExtractZipFile(zipFilePath, targetDirPath string, deleteZipFile bool, fileNamesPrefix string, fileNamesToExtract ...string) error</pre>
			<p>
Extracts a ZIP archive to the local file system.
zipFilePath: full file path to the ZIP archive file.
targetDirPath: directory path where un-zipped archive contents are extracted to.
deleteZipFile: deletes the ZIP archive file upon successful extraction.
</p>

			
		
			
			
			<h2 id="FileExists">func <a href="/target/io.go?s=3924:3957#L131">FileExists</a></h2>
			<pre>func FileExists(path string) bool</pre>
			<p>
Returns true if a file (not a directory) exists at the specified path.
</p>

			
		
			
			
			<h2 id="FindFileInfo">func <a href="/target/io.go?s=4288:4436#L140">FindFileInfo</a></h2>
			<pre>func FindFileInfo(dirPath string, fileBaseName string, fileExts []string, tryLower bool, tryUpper bool) (fullFilePath string, fileInfo *os.FileInfo)</pre>
			<p>
If a file with a given base-name and one of a set of extensions exists in the specified directory, returns details on it.
The tryLower and tryUpper flags also test for upper-case and lower-case variants of the specified fileBaseName.
</p>

			
		
			
			
			<h2 id="ReadBinaryFile">func <a href="/target/io.go?s=5191:5253#L168">ReadBinaryFile</a></h2>
			<pre>func ReadBinaryFile(filePath string, panicOnError bool) []byte</pre>
			<p>
Reads and returns the binary contents of a file with non-idiomatic error handling:
filePath: full local file path
panicOnError: true to panic() if an error occurred reading the file
</p>

			
		
			
			
			<h2 id="ReadFromBinary">func <a href="/target/io.go?s=5598:5707#L178">ReadFromBinary</a></h2>
			<pre>func ReadFromBinary(readSeeker io.ReadSeeker, offset int64, byteOrder binary.ByteOrder, ptr interface{}) bool</pre>
			<p>
Reads binary data into the specified interface{} from the specified io.ReadSeeker at the specified offset using the specified binary.ByteOrder.
Returns false if data could not be successfully read as specified, otherwise true.
</p>

			
		
			
			
			<h2 id="ReadTextFile">func <a href="/target/io.go?s=6217:6292#L193">ReadTextFile</a></h2>
			<pre>func ReadTextFile(filePath string, panicOnError bool, defVal string) string</pre>
			<p>
Reads and returns the contents of a text file with non-idiomatic error handling:
filePath: full local file path
panicOnError: true to panic() if an error occurred reading the file, or false to return defVal in the case of error
defVal: the string value to return if the file couldn&#39;t be read successfully
</p>

			
		
			
			
			<h2 id="SaveToFile">func <a href="/target/io.go?s=6531:6588#L205">SaveToFile</a></h2>
			<pre>func SaveToFile(r io.Reader, filename string) (err error)</pre>
			<p>
Performs an io.Copy() from the specified io.Reader to the specified local file.
</p>

			
		
			
			
			<h2 id="WalkerVisitorNoop">func <a href="/target/walker.go?s=498:564#L5">WalkerVisitorNoop</a></h2>
			<pre>func WalkerVisitorNoop(_ *DirWalker, _ string, _ os.FileInfo) bool</pre>
			<p>
An empty WalkerVisitor used in place of a nil DirWalker.DirVisitor or a nil DirWalker.FileVisitor during a DirWalker.Walk(). Returns true.
</p>

			
		
			
			
			<h2 id="WriteBinaryFile">func <a href="/target/io.go?s=6877:6937#L219">WriteBinaryFile</a></h2>
			<pre>func WriteBinaryFile(filePath string, contents []byte) error</pre>
			<p>
A short-hand for ioutil.WriteFile, without needing to specify os.ModePerm.
Also ensures the target file&#39;s directory exists.
</p>

			
		
			
			
			<h2 id="WriteTextFile">func <a href="/target/io.go?s=7190:7241#L226">WriteTextFile</a></h2>
			<pre>func WriteTextFile(filePath, contents string) error</pre>
			<p>
A short-hand for ioutil.WriteFile, without needing to specify os.ModePerm or string-conversion.
Also ensures the target file&#39;s directory exists.
</p>

			
		
		
			
			
			<h2 id="DirWalker">type <a href="/target/walker.go?s=1296:2057#L25">DirWalker</a></h2>
			<pre>type DirWalker struct {
    <span class="comment">//	Walk() returns a slice of all errors encountered but</span>
    <span class="comment">//	to cancel walking upon the first error, set this to true.</span>
    BreakOnError bool

    <span class="comment">//	After invoking DirVisitor on the specified directory, by default</span>
    <span class="comment">//	its files get visited first before visiting its sub-directories.</span>
    <span class="comment">//	If VisitDirsFirst is true, then files get visited last, after</span>
    <span class="comment">//	having visited all sub-directories.</span>
    VisitDirsFirst bool

    <span class="comment">//	Defaults to true. If false, only the files in the specified directory</span>
    <span class="comment">//	(and the directory itself) get visited, but no sub-directories.</span>
    VisitSubDirs bool

    <span class="comment">//	Called for every directory being visited during Walk().</span>
    DirVisitor WalkerVisitor

    <span class="comment">//	Called for every file being visited during Walk().</span>
    FileVisitor WalkerVisitor
}</pre>
			<p>
Provides recursive directory walking with a variety of options.
</p>


			

			

			

			
				
				<h3 id="NewDirWalker">func <a href="/target/walker.go?s=2142:2214#L48">NewDirWalker</a></h3>
				<pre>func NewDirWalker(dirVisitor, fileVisitor WalkerVisitor) (me *DirWalker)</pre>
				<p>
Initializes and returns a new DirWalker with the specified (optional) visitors.
</p>

				
			

			
				
				<h3 id="DirWalker.Walk">func (*DirWalker) <a href="/target/walker.go?s=2372:2428#L54">Walk</a></h3>
				<pre>func (me *DirWalker) Walk(dirPath string) (errs []error)</pre>
				<p>
Initiates me walking through the specified directory.
</p>

				
				
			
		
			
			
			<h2 id="WalkerVisitor">type <a href="/target/walker.go?s=254:354#L2">WalkerVisitor</a></h2>
			<pre>type WalkerVisitor func(walker *DirWalker, fullPath string, fileInfo os.FileInfo) (keepWalking bool)</pre>
			<p>
Used for DirWalker.DirVisitor and DirWalker.FileVisitor. Always check fileInfo for nil!
Always return keepWalking as true unless you want to immediately terminate a Walk() early.
</p>


			

			

			

			
				
				<h3 id="NewWalkerVisitor_IsNewerThan">func <a href="/target/walker.go?s=856:944#L12">NewWalkerVisitor_IsNewerThan</a></h3>
				<pre>func NewWalkerVisitor_IsNewerThan(testTime time.Time, fileTime *time.Time) WalkerVisitor</pre>
				<p>
Returns a new WalkerVisitor that during a DirWalker.Walk() tracks FileInfo.ModTime() for all visited files
and/or directories, always storing the newest one in fileTime, and terminating early as soon as fileTime
records a value higher than the specified testTime.
</p>

				
			

			
		
		</div>
	

	








		</div></div>
	</body>
</html>