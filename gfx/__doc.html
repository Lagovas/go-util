<html>
	<head>
		<title>Package github.com/metaleap/go-util/gfx</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/metaleap/go-util/gfx</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/metaleap/go-util/gfx"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
General helpers for working with graphics, imagery and picture sampling.
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#Index2D">func Index2D(x, y, ysize int) int</a></dd>
			
				
				<dd><a href="#Index3D">func Index3D(x, y, z, xsize, ysize int) int</a></dd>
			
				
				<dd><a href="#PreprocessImage">func PreprocessImage(src image.Image, dst Picture, flipY, toBgra, toLinear bool)</a></dd>
			
				
				<dd><a href="#SavePngImageFile">func SavePngImageFile(img image.Image, filePath string) error</a></dd>
			
			
				
				<dd><a href="#Picture">type Picture</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CloneImage">func CloneImage(src image.Image, copyPixels bool) (dst Picture, pix []byte)</a></dd>
				
				
			
				
				<dd><a href="#Rgba32">type Rgba32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRgba32">func NewRgba32(vals ...float64) (me *Rgba32)</a></dd>
				
				
			
				
				<dd><a href="#Rgba64">type Rgba64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRgba64">func NewRgba64(vals ...float64) (me *Rgba64)</a></dd>
				
				
			
				
				<dd><a href="#SamplerWrapping">type SamplerWrapping</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSamplerWrapping">func NewSamplerWrapping(stp WrapKind, borderColor *Rgba32) (me *SamplerWrapping)</a></dd>
				
				
			
				
				<dd><a href="#WrapKind">type WrapKind</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/gfx.go">gfx.go</a>
			
				<a href="/target/img.go">img.go</a>
			
				<a href="/target/sampling.go">sampling.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		
		
		
			
			
			<h2 id="Index2D">func <a href="/target/gfx.go?s=1626:1659#L62">Index2D</a></h2>
			<pre>func Index2D(x, y, ysize <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
If 2-dimensions are represented in a 1-dimensional linear array, this function provides one way to return a 1D index addressing a 2D coordinate...
</p>

			
		
			
			
			<h2 id="Index3D">func <a href="/target/gfx.go?s=1839:1882#L67">Index3D</a></h2>
			<pre>func Index3D(x, y, z, xsize, ysize <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>
If 3-dimensions are represented in a 1-dimensional linear array, this function provides one way to return a 1D index addressing a 3D coordinate...
</p>

			
		
			
			
			<h2 id="PreprocessImage">func <a href="/target/img.go?s=2089:2169#L70">PreprocessImage</a></h2>
			<pre>func PreprocessImage(src <a href="/pkg/image/">image</a>.<a href="/pkg/image/#Image">Image</a>, dst <a href="#Picture">Picture</a>, flipY, toBgra, toLinear <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>
Processes the specified Image and writes the result to the specified Picture.
Unless flipY is true, dst and src may well be the same object.
If flipY is true, all pixel rows are inverted (dst becomes src vertically mirrored).
If toBgra is true, all pixels&#39; red and green components are swapped.
If toLinear is true, all pixels are converted from gamma/sRGB to linear space.
</p>

			
		
			
			
			<h2 id="SavePngImageFile">func <a href="/target/gfx.go?s=1974:2035#L72">SavePngImageFile</a></h2>
			<pre>func SavePngImageFile(img <a href="/pkg/image/">image</a>.<a href="/pkg/image/#Image">Image</a>, filePath <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#error">error</a></pre>
			<p>
Saves any given image as a local PNG file.
</p>

			
		
		
			
			
			<h2 id="Picture">type <a href="/target/img.go?s=176:289#L4">Picture</a></h2>
			<pre>type Picture interface {
    <a href="/pkg/image/">image</a>.<a href="/pkg/image/#Image">Image</a>

    <span class="comment">//	Set pixel at x,y to the specified color.</span>
    Set(<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#int">int</a>, <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)
}</pre>
			<p>
The interface that the image package was missing...
</p>


			

			

			

			
				
				<h3 id="CloneImage">func <a href="/target/img.go?s=498:573#L14">CloneImage</a></h3>
				<pre>func CloneImage(src <a href="/pkg/image/">image</a>.<a href="/pkg/image/#Image">Image</a>, copyPixels <a href="/pkg/builtin/#bool">bool</a>) (dst <a href="#Picture">Picture</a>, pix []<a href="/pkg/builtin/#byte">byte</a>)</pre>
				<p>
Creates and returns a copy of src.
If copyPixels is true, pixels in src are copied to dst, otherwise dst will be an
empty/black image of the same dimensions, color format, stride/offset/etc as src.
</p>

				
			

			
		
			
			
			<h2 id="Rgba32">type <a href="/target/gfx.go?s=139:282#L1">Rgba32</a></h2>
			<pre>type Rgba32 struct {
    <span class="comment">//	Red component</span>
    R <a href="/pkg/builtin/#float32">float32</a>
    <span class="comment">//	Green component</span>
    G <a href="/pkg/builtin/#float32">float32</a>
    <span class="comment">//	Blue component</span>
    B <a href="/pkg/builtin/#float32">float32</a>
    <span class="comment">//	Alpha component</span>
    A <a href="/pkg/builtin/#float32">float32</a>
}</pre>
			<p>
Describes a literal color using four 32-bit floating-point numbers in RGBA order.
</p>


			

			

			

			
				
				<h3 id="NewRgba32">func <a href="/target/gfx.go?s=474:518#L14">NewRgba32</a></h3>
				<pre>func NewRgba32(vals ...<a href="/pkg/builtin/#float64">float64</a>) (me *<a href="#Rgba32">Rgba32</a>)</pre>
				<p>
Converts the specified vals to a newly initialized Rgba32 instance.
The first 4 vals are used for R, G, B, and A in that order, if present.
A is set to 1 if vals[3] is not present.
</p>

				
			

			
		
			
			
			<h2 id="Rgba64">type <a href="/target/gfx.go?s=868:1011#L31">Rgba64</a></h2>
			<pre>type Rgba64 struct {
    <span class="comment">//	Red component</span>
    R <a href="/pkg/builtin/#float64">float64</a>
    <span class="comment">//	Green component</span>
    G <a href="/pkg/builtin/#float64">float64</a>
    <span class="comment">//	Blue component</span>
    B <a href="/pkg/builtin/#float64">float64</a>
    <span class="comment">//	Alpha component</span>
    A <a href="/pkg/builtin/#float64">float64</a>
}</pre>
			<p>
Describes a literal color using four 64-bit floating-point numbers in RGBA order.
</p>


			

			

			

			
				
				<h3 id="NewRgba64">func <a href="/target/gfx.go?s=1203:1247#L45">NewRgba64</a></h3>
				<pre>func NewRgba64(vals ...<a href="/pkg/builtin/#float64">float64</a>) (me *<a href="#Rgba64">Rgba64</a>)</pre>
				<p>
Converts the specified vals to a newly initialized Rgba64 instance.
The first 4 vals are used for R, G, B, and A in that order, if present.
A is set to 1 if vals[3] is not present.
</p>

				
			

			
		
			
			
			<h2 id="SamplerWrapping">type <a href="/target/sampling.go?s=1495:2086#L24">SamplerWrapping</a></h2>
			<pre>type SamplerWrapping struct {
    <span class="comment">//	When reading past the edge of the texture address space</span>
    <span class="comment">//	based on the wrap modes involving clamps, this color takes over.</span>
    BorderColor <a href="#Rgba32">Rgba32</a>

    <span class="comment">//	Controls texture repeating and clamping of the S coordinate.</span>
    <span class="comment">//	Must be one of the WrapKind* enumerated constants.</span>
    WrapS <a href="#WrapKind">WrapKind</a>

    <span class="comment">//	Controls texture repeating and clamping of the T coordinate.</span>
    <span class="comment">//	Must be one of the WrapKind* enumerated constants.</span>
    WrapT <a href="#WrapKind">WrapKind</a>

    <span class="comment">//	Controls texture repeating and clamping of the P coordinate.</span>
    <span class="comment">//	Must be one of the WrapKind* enumerated constants.</span>
    WrapP <a href="#WrapKind">WrapKind</a>
}</pre>
			<p>
Controls texture repeating and clamping.
</p>


			

			

			

			
				
				<h3 id="NewSamplerWrapping">func <a href="/target/sampling.go?s=2245:2325#L44">NewSamplerWrapping</a></h3>
				<pre>func NewSamplerWrapping(stp <a href="#WrapKind">WrapKind</a>, borderColor *<a href="#Rgba32">Rgba32</a>) (me *<a href="#SamplerWrapping">SamplerWrapping</a>)</pre>
				<p>
Initializes a new SamplerWrapping with the specified coordinate wrappings
and borderColor. If no borderColor is specified, black (0, 0, 0, 1) is used.
</p>

				
			

			
		
			
			
			<h2 id="WrapKind">type <a href="/target/sampling.go?s=76:93#L1">WrapKind</a></h2>
			<pre>type WrapKind <a href="/pkg/builtin/#int">int</a></pre>
			<p>
Categorizes the kinds of wrapping used in SamplerWrapping.
</p>


			
				<pre>const (
    <span class="comment">//	Ignores the integer part of texture coordinates, using only the fractional part and tiling the</span>
    <span class="comment">//	texture at every integer junction. For example, for u values between 0 and 3, the texture is</span>
    <span class="comment">//	repeated three times; no mirroring is performed.</span>
    <span id="WrapKindRepeat">WrapKindRepeat</span> <a href="#WrapKind">WrapKind</a> = 0x2901

    <span class="comment">//	First mirrors the texture coordinate. The mirrored coordinate is then clamped as described for</span>
    <span class="comment">//	WrapKindClamp. Flips the texture at every integer junction. For u values between 0 and 1,</span>
    <span class="comment">//	for example, the texture is addressed normally; between 1 and 2, the texture is flipped (mirrored);</span>
    <span class="comment">//	between 2 and 3, the texture is normal again; and so on.</span>
    <span id="WrapKindMirror">WrapKindMirror</span> <a href="#WrapKind">WrapKind</a> = 0x8370

    <span class="comment">//	Clamps texture coordinates at all MIPmap levels such that</span>
    <span class="comment">//	the texture filter never samples a border texel.</span>
    <span id="WrapKindClamp">WrapKindClamp</span> <a href="#WrapKind">WrapKind</a> = 0x812F

    <span class="comment">//	Clamps texture coordinates at all MIPmaps such that the texture filter always samples border</span>
    <span class="comment">//	texels for fragments whose corresponding texture coordinate is sufficiently far outside</span>
    <span class="comment">//	the range [0, 1]. Much like WrapKindClamp, except texture coordinates outside</span>
    <span class="comment">//	the range [0.0, 1.0] are set to the border color.</span>
    <span id="WrapKindBorder">WrapKindBorder</span> <a href="#WrapKind">WrapKind</a> = 0x812D

    <span class="comment">//	Takes the absolute value of the texture coordinate (thus, mirroring around 0),</span>
    <span class="comment">//	and then clamps to the maximum value.</span>
    <span id="WrapKindMirrorOnce">WrapKindMirrorOnce</span> <a href="#WrapKind">WrapKind</a> = 41
)</pre>
				
			

			

			

			

			
		
	

	








		</div></div>
	</body>
</html>