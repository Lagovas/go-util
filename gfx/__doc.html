<html>
	<head>
		<title>Package github.com/metaleap/go-util/gfx</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/metaleap/go-util/gfx</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/metaleap/go-util/gfx"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
General helpers for working with graphics, imagery and picture sampling.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#FlipVertical">func FlipVertical(src image.Image, dst Image)</a></dd>
			
				
				<dd><a href="#Index2D">func Index2D(x, y, ysize int) int</a></dd>
			
				
				<dd><a href="#Index3D">func Index3D(x, y, z, xsize, ysize int) int</a></dd>
			
				
				<dd><a href="#SavePngImageFile">func SavePngImageFile(img image.Image, filePath string) error</a></dd>
			
			
				
				<dd><a href="#Image">type Image</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CloneImage">func CloneImage(src image.Image, copyPixels bool) (dst Image)</a></dd>
				
				
			
				
				<dd><a href="#Rgba32">type Rgba32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRgba32">func NewRgba32(vals ...float64) (me *Rgba32)</a></dd>
				
				
			
				
				<dd><a href="#Rgba64">type Rgba64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRgba64">func NewRgba64(vals ...float64) (me *Rgba64)</a></dd>
				
				
			
				
				<dd><a href="#SamplerWrapping">type SamplerWrapping</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSamplerWrapping">func NewSamplerWrapping(stp WrapKind, borderColor *Rgba32) (me *SamplerWrapping)</a></dd>
				
				
			
				
				<dd><a href="#WrapKind">type WrapKind</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/gfx.go">gfx.go</a>
			
				<a href="/target/img.go">img.go</a>
			
				<a href="/target/sampling.go">sampling.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="FlipVertical">func <a href="/target/img.go?s=1360:1405#L57">FlipVertical</a></h2>
			<pre>func FlipVertical(src image.Image, dst Image)</pre>
			
			
		
			
			
			<h2 id="Index2D">func <a href="/target/gfx.go?s=1626:1659#L62">Index2D</a></h2>
			<pre>func Index2D(x, y, ysize int) int</pre>
			<p>
If 2-dimensions are represented in a 1-dimensional linear array, this function provides one way to return a 1D index addressing a 2D coordinate...
</p>

			
		
			
			
			<h2 id="Index3D">func <a href="/target/gfx.go?s=1839:1882#L67">Index3D</a></h2>
			<pre>func Index3D(x, y, z, xsize, ysize int) int</pre>
			<p>
If 3-dimensions are represented in a 1-dimensional linear array, this function provides one way to return a 1D index addressing a 3D coordinate...
</p>

			
		
			
			
			<h2 id="SavePngImageFile">func <a href="/target/gfx.go?s=1974:2035#L72">SavePngImageFile</a></h2>
			<pre>func SavePngImageFile(img image.Image, filePath string) error</pre>
			<p>
Saves any given image as a local PNG file.
</p>

			
		
		
			
			
			<h2 id="Image">type <a href="/target/img.go?s=50:102#L1">Image</a></h2>
			<pre>type Image interface {
    Set(int, int, color.Color)
}</pre>
			

			

			

			

			
				
				<h3 id="CloneImage">func <a href="/target/img.go?s=104:165#L2">CloneImage</a></h3>
				<pre>func CloneImage(src image.Image, copyPixels bool) (dst Image)</pre>
				
				
			

			
		
			
			
			<h2 id="Rgba32">type <a href="/target/gfx.go?s=139:282#L1">Rgba32</a></h2>
			<pre>type Rgba32 struct {
    <span class="comment">//	Red component</span>
    R float32
    <span class="comment">//	Green component</span>
    G float32
    <span class="comment">//	Blue component</span>
    B float32
    <span class="comment">//	Alpha component</span>
    A float32
}</pre>
			<p>
Describes a literal color using four 32-bit floating-point numbers in RGBA order.
</p>


			

			

			

			
				
				<h3 id="NewRgba32">func <a href="/target/gfx.go?s=474:518#L14">NewRgba32</a></h3>
				<pre>func NewRgba32(vals ...float64) (me *Rgba32)</pre>
				<p>
Converts the specified vals to a newly initialized Rgba32 instance.
The first 4 vals are used for R, G, B, and A in that order, if present.
A is set to 1 if vals[3] is not present.
</p>

				
			

			
		
			
			
			<h2 id="Rgba64">type <a href="/target/gfx.go?s=868:1011#L31">Rgba64</a></h2>
			<pre>type Rgba64 struct {
    <span class="comment">//	Red component</span>
    R float64
    <span class="comment">//	Green component</span>
    G float64
    <span class="comment">//	Blue component</span>
    B float64
    <span class="comment">//	Alpha component</span>
    A float64
}</pre>
			<p>
Describes a literal color using four 64-bit floating-point numbers in RGBA order.
</p>


			

			

			

			
				
				<h3 id="NewRgba64">func <a href="/target/gfx.go?s=1203:1247#L45">NewRgba64</a></h3>
				<pre>func NewRgba64(vals ...float64) (me *Rgba64)</pre>
				<p>
Converts the specified vals to a newly initialized Rgba64 instance.
The first 4 vals are used for R, G, B, and A in that order, if present.
A is set to 1 if vals[3] is not present.
</p>

				
			

			
		
			
			
			<h2 id="SamplerWrapping">type <a href="/target/sampling.go?s=1495:2086#L24">SamplerWrapping</a></h2>
			<pre>type SamplerWrapping struct {
    <span class="comment">//	When reading past the edge of the texture address space</span>
    <span class="comment">//	based on the wrap modes involving clamps, this color takes over.</span>
    BorderColor Rgba32

    <span class="comment">//	Controls texture repeating and clamping of the S coordinate.</span>
    <span class="comment">//	Must be one of the WrapKind* enumerated constants.</span>
    WrapS WrapKind

    <span class="comment">//	Controls texture repeating and clamping of the T coordinate.</span>
    <span class="comment">//	Must be one of the WrapKind* enumerated constants.</span>
    WrapT WrapKind

    <span class="comment">//	Controls texture repeating and clamping of the P coordinate.</span>
    <span class="comment">//	Must be one of the WrapKind* enumerated constants.</span>
    WrapP WrapKind
}</pre>
			<p>
Controls texture repeating and clamping.
</p>


			

			

			

			
				
				<h3 id="NewSamplerWrapping">func <a href="/target/sampling.go?s=2245:2325#L44">NewSamplerWrapping</a></h3>
				<pre>func NewSamplerWrapping(stp WrapKind, borderColor *Rgba32) (me *SamplerWrapping)</pre>
				<p>
Initializes a new SamplerWrapping with the specified coordinate wrappings
and borderColor. If no borderColor is specified, black (0, 0, 0, 1) is used.
</p>

				
			

			
		
			
			
			<h2 id="WrapKind">type <a href="/target/sampling.go?s=76:93#L1">WrapKind</a></h2>
			<pre>type WrapKind int</pre>
			<p>
Categorizes the kinds of wrapping used in SamplerWrapping.
</p>


			
				<pre>const (
    <span class="comment">//	Ignores the integer part of texture coordinates, using only the fractional part and tiling the</span>
    <span class="comment">//	texture at every integer junction. For example, for u values between 0 and 3, the texture is</span>
    <span class="comment">//	repeated three times; no mirroring is performed.</span>
    WrapKindRepeat WrapKind = 0x2901

    <span class="comment">//	First mirrors the texture coordinate. The mirrored coordinate is then clamped as described for</span>
    <span class="comment">//	WrapKindClamp. Flips the texture at every integer junction. For u values between 0 and 1,</span>
    <span class="comment">//	for example, the texture is addressed normally; between 1 and 2, the texture is flipped (mirrored);</span>
    <span class="comment">//	between 2 and 3, the texture is normal again; and so on.</span>
    WrapKindMirror WrapKind = 0x8370

    <span class="comment">//	Clamps texture coordinates at all MIPmap levels such that</span>
    <span class="comment">//	the texture filter never samples a border texel.</span>
    WrapKindClamp WrapKind = 0x812F

    <span class="comment">//	Clamps texture coordinates at all MIPmaps such that the texture filter always samples border</span>
    <span class="comment">//	texels for fragments whose corresponding texture coordinate is sufficiently far outside</span>
    <span class="comment">//	the range [0, 1]. Much like WrapKindClamp, except texture coordinates outside</span>
    <span class="comment">//	the range [0.0, 1.0] are set to the border color.</span>
    WrapKindBorder WrapKind = 0x812D

    <span class="comment">//	Takes the absolute value of the texture coordinate (thus, mirroring around 0),</span>
    <span class="comment">//	and then clamps to the maximum value.</span>
    WrapKindMirrorOnce WrapKind = 41
)</pre>
				
			

			

			

			

			
		
		</div>
	

	








		</div></div>
	</body>
</html>